<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<!DOCTYPE html>
<link rel="stylesheet" href="include/style.css">

<!-- Include relevant libraries -->
<script type="text/javascript" src="js/eclib.js"></script>
<script type="text/javascript" src="js/units.js"></script>
<script type="text/javascript" src="js/export.js"></script>
<script type="text/javascript" src="js/motors.js"></script>
<script type="text/javascript" src="js/plots.js"></script>
<script type="text/javascript" src="js/math.js"></script>
<script type="text/javascript" src="js/materials.js"></script>
<script type="text/javascript" src="js/walkthrough.js"></script>

<!-- Export library requires this script tag -->
<script id="EXP_inputs_frame" ></script>

<script type="text/javascript">
	EXP_FN_BASE = 'beam'; // this is needed for persistence, too.
	UNIT_MAP = {
		'force':           ['N', 'lbf'],
		'elastic_modulus': ['GPa', '10^6 psi'],
		'moi':       ['mm^4', 'in^4'],
		'area': 	 ['mm^2', 'in^2'],
		'dimension': ['mm', 'in'],
		'deflection':['mm', 'thou'],
		'torque':    ['N-m', 'ft-lbf'],
		'slope':     ['deg', 'deg'],
		'density':   ['g/cm^3', 'lbm/in^3'],
		'mass':      ['kg',  'lbm'],
		'stress':    ['MPa', 'psi']
	}
	WALK_STEPS = [{
			poi: 'user_input_material',
			desc: 'Select material.',
			halign: 'left',
			valign: 'below'
		},{
			poi: 'user_input_section',
			desc: 'Define cross-section.',
			halign: 'left',
			valign: 'below'
		},{
			poi: 'loads',
			desc: 'Define loads and constraints.',
			halign: 'left',
			valign: 'above'
		},{
			poi: 'addLoad_btn',
			desc: 'More loads can be added.',
			halign: 'left',
			valign: 'above'
		},{
			poi: 'chart_background',
			desc: 'Deflection diagram will appear here.'
		},{
			poi: 'chart_background',
			desc: 'Click on the graph to poll particular points for values.'
		},{
			poi: 'beam_background',
			desc: 'Loads and constraints are visualized here.'
		},{
			poi: 'beam_background',
			desc: 'You can also click on parts of the beam to probe them.'
		},{
			poi: 'toggle_tips_label',
			desc: 'More notes are here in this box and tooltips.',
			halign: 'left',
			valign: 'above'
		}];
</script>
<script type="text/javascript">
	function init() {
		// basic loading, create options dynamically
		EC_onload();
		populateMaterials();

		// load persistence or exported values
		switch(EXP_onload()) {
			case 0: // run when nothing loads
				addLoad({where: 10, amount: 0, type: 0});
				addLoad({where: 50, amount: 0, type: 0});
				addLoad({where: 90, amount: 100, type: 2});
				addLoad({where: 10, amount: -10, type: 3});
				document.getElementById('length').value = 100;
				document.getElementById('material').value = 'Aluminum';
				break;
			case 1: // run when export loads
				break;
			case 2: // run when local storage loads
				loadDynamicPersistence();
				break;
		}

		UNIT_change();
		populateMaterials();
		document.getElementById('material').value = 'Aluminum';
		selectMaterial();
		selectShape();
		computeMOI();

		registerCallbacks();

		compute();
		WALK_onload();
	}

	function registerCallbacks() {
		EC_setOnInput(function(e) {
	    	let key = e.keyCode ? e.keyCode : e.which;
	    	let input = e.target;
	    	if(input.id.startsWith('toggle')) return; // ignore these, just css stuff
	    	if(input.id.startsWith('section_')) {
	    		computeMOI();
	    	}
			if(key!=13) setError(1);
	    });
		EC_setOnKeyUp(); // default handler OK
	}

	function computeMOI() {
		setError(1);
		shape = document.getElementById('section').value;
		var moi, area, rmax, rmin;
		flip = document.getElementById('section_flip').checked;
		if (shape == 'rndbar') {
			d = getV('section_1');
			rmax = rmin = d/2;
			area = Math.PI/4 * d*d;
			moi = Math.PI/64*Math.pow(d,4);
		} else if (shape == 'boxbar') {
			w = getV('section_1');
			h = getV('section_2');
			rmax = rmin = h/2;
			area = w*h;
			moi = w*Math.pow(h,3)/12;
		} else if (shape == 'boxtube') {
			w = getV('section_1');
			h = getV('section_2');
			t = getV('section_3');
			rmax = rmin = h/2;
			area = w*h - (w-2*t)*(h-2*t);
			moi = (w*Math.pow(h,3) - (w-2*t)*Math.pow(h-2*t,3))/12;
		} else if (shape == 'angle') {
			a = getV('section_1');
			b = getV('section_2');
			t = getV('section_3');
			d = b - t;
			c = a - t;
			rmin = (t*(2*d+a)+d*d)/2/(d+a);
			rmax = b-rmin;
			area = a*b - c*d;
			moi  = 1/3*(t*Math.pow(rmax, 3)+ a*Math.pow(b-rmax,3 ) - (a-t)*Math.pow(b-rmax-t, 3));
			if(flip) {
				tmp  = rmax;
				rmax = rmin;
				rmin = tmp;
			}
		} else if (shape == 'channel') {
			b = getV('section_1');
			d = getV('section_2');
			t = getV('section_3');
			s = t;
			h = d-2*s;
			area = 2*s*b + h*t
			if(flip) {
				rmin = (2*b*b*s + h*t*t)/(2*b*d-2*h*(b-t));
				rmax = b - rmin;
				moi  = (2*s*b*b*b + h*t*t*t)/3 - area*rmin*rmin;
			} else {
				rmin = rmax = d/2;
				moi  = (b*d*d*d - h*h*h*(b-t))/12;
			}
		} else if (shape == 'rndtube') {
			d = getV('section_1');
			t = getV('section_2');
			rmax = rmin = d/2;
			area = Math.PI/4 * (d*d-(d-2*t)*(d-2*t));
			moi = Math.PI/64*(Math.pow(d,4)-Math.pow(d-2*t,4));
		} else if (shape == 'hex') {
			a = getV('section_1')/2; //side length
			id = getV('section_2');
			if (isNaN(id)) id = 0;
			area = Math.sqrt(3)*3/2*a*a 			- Math.PI/4 * id*id;
			moi  = 5/16*Math.sqrt(3)*Math.pow(a, 4) - Math.PI/64*Math.pow(id,4);
			rmax = rmin = flip ? a : (a*2/Math.sqrt(3));
		}

		if (shape != 'custom') {
			setV("moi", moi);
			setV("area", area);
			setV("rmax", rmax);
			setV("rmin", rmin);
		}

	}

	function selectShape(disable_recompute) {
		if(!disable_recompute) setError(1);
		shape = document.getElementById('section').value;
		document.getElementById('moi').readOnly = true;
		document.getElementById('area').readOnly = true;
		document.getElementById('rmax').readOnly = true;
		document.getElementById('rmin').readOnly = true;
		if (typeof EXP_inputs == 'undefined')
			document.getElementById('section_img').src = 'include/section_' + shape + '.svg'; // workaround: only set the image if not exported
		if (shape == 'custom') {
			document.getElementById('moi').readOnly  = false;
			document.getElementById('area').readOnly = false;
			document.getElementById('rmax').readOnly = false;
			document.getElementById('rmin').readOnly = false;
			document.getElementById('section_flip_row').style.display = 'none';
			for (i=1;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'rndbar') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Diameter';
			document.getElementById('section_flip_row').style.display = 'none';
			for (i=2;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'boxbar') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Width';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'Height';
			document.getElementById('section_flip_row').style.display = 'none';
			for (i=3;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'boxtube') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Width';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'Height';
			document.getElementById('section_3_row').style.display = '';
			document.getElementById('section_3_label').innerHTML = 'Thickness';
			document.getElementById('section_flip_row').style.display = 'none';
			for (i=4;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'channel') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Width';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'Height';
			document.getElementById('section_3_row').style.display = '';
			document.getElementById('section_3_label').innerHTML = 'Thickness';
			document.getElementById('section_flip_row').style.display = '';
			document.getElementById('section_flip_label').innerHTML = 'Rotate 90?';
			for (i=4;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'angle') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Width';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'Height';
			document.getElementById('section_3_row').style.display = '';
			document.getElementById('section_3_label').innerHTML = 'Thickness';
			document.getElementById('section_flip_row').style.display = '';
			document.getElementById('section_flip_label').innerHTML = 'Flip 180?';
			for (i=4;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'rndtube') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'OD';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'Thickness';
			document.getElementById('section_flip_row').style.display = 'none';
			for (i=3;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'hex') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Width';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'ID';
			document.getElementById('section_flip_row').style.display = '';
			document.getElementById('section_flip_label').innerHTML = 'Rotate 90?';
			for (i=3;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		}
		if (!disable_recompute) {
			computeMOI();
			selectMaterial();
		}
	}

	function addLoad(params) {
		setError(1);
		let loads = document.getElementById('loads');
		let load_div = document.createElement('div');
		x = loads.dataset.current_load_number;
		loads.dataset.current_load_number ++;
		load_div.innerHTML =
		`<table data-load_id=${x}>
			<tr>
				<td>[${x}] <button onclick="removeLoad(${x}); compute();" title="Remove">-</button></td>
				<td><select class="dynamic-input" id="load_type_${x}" onchange="selectLoadType(${x}); compute();">
					<option value="pin" selected='selected' >Pinned</option>
					<option value="fix">Fixed</option>
					<option value="force">Force </option>
					<option value="moment">Moment</option>
					<option value="displacement">Displacement</option>
					<option value="slope">Slope</option>
				</select></td>
			</tr>
			<tr id="load_${x}_1_row">
				<th class="rowlabel" id="load_${x}_1_label">L1</th>
				<td><input id="load_${x}_1" class="dynamic-input" onchange="drawBeam()" data-unit="dimension" /></td>
				<td class="unit" id="load_${x}_1_unit" data-unit="dimension"></td>
			</tr><tr id="load_${x}_2_row">
				<th class="rowlabel" id="load_${x}_2_label">L2</th>
				<td><input id="load_${x}_2" class="dynamic-input" onchange="drawBeam()" data-unit="dimension" /></td>
				<td class="unit" id="load_${x}_2_unit" data-unit="dimension"></td>
			</tr><tr id="load_${x}_3_row">
				<th class="rowlabel" id="load_${x}_3_label">L3</th>
				<td><input id="load_${x}_3" class="dynamic-input" onchange="drawBeam()" data-unit="dimension" /></td>
				<td class="unit" id="load_${x}_3_unit" data-unit="dimension"></td>
			</tr><tr id="load_${x}_4_row">
				<th class="rowlabel" id="load_${x}_4_label">L4</th>
				<td><input id="load_${x}_4" class="dynamic-input" onchange="drawBeam()" data-unit="dimension"/></td>
				<td class="unit" id="load_${x}_4_unit" data-unit="dimension"></td>
			</tr>
		</table>`;
		load_div.dataset.load_id = x;
		load_div.classList.add(x%2 ? 'even' : 'odd');
		load_div.classList.add('load');
		loads.insertBefore(load_div, loads.lastChild);

		if (typeof params != 'undefined') {
			document.getElementById(`load_${x}_1`).value = params.where;
			document.getElementById(`load_${x}_2`).value = params.amount;
			document.getElementById(`load_type_${x}`).selectedIndex = params.type;
		}
		selectLoadType(x);
		registerCallbacks();
	}

	function selectLoadType(i) {
		setError(1);
		type = document.getElementById('load_type_'+i).value;
		if (type == 'pin' ) { //
			document.getElementById(`load_${i}_1_row`).style.display = '';
			document.getElementById(`load_${i}_1_label`).innerHTML = 'At x=';
			document.getElementById(`load_${i}_1`).readOnly = false;
			document.getElementById(`load_${i}_1`).dataset.unit = 'dimension';
			document.getElementById(`load_${i}_1_unit`).dataset.unit = 'dimension';

			document.getElementById(`load_${i}_2_row`).style.display = '';
			document.getElementById(`load_${i}_2_label`).innerHTML = 'F=';
			document.getElementById(`load_${i}_2`).readOnly = true;
			document.getElementById(`load_${i}_2`).dataset.unit = 'force';
			document.getElementById(`load_${i}_2_unit`).dataset.unit = 'force';
			for (j=3;j<=4;j++)
				document.getElementById(`load_${i}_${j}_row`).style.display = 'none';
		} else if (type == 'fix' ) { //
			document.getElementById(`load_${i}_1_row`).style.display = '';
			document.getElementById(`load_${i}_1_label`).innerHTML = 'At x=';
			document.getElementById(`load_${i}_1`).readOnly = false;
			document.getElementById(`load_${i}_1`).dataset.unit = 'dimension';
			document.getElementById(`load_${i}_1_unit`).dataset.unit = 'dimension';

			document.getElementById(`load_${i}_2_row`).style.display = '';
			document.getElementById(`load_${i}_2_label`).innerHTML = 'F=';
			document.getElementById(`load_${i}_2`).readOnly = true;
			document.getElementById(`load_${i}_2`).dataset.unit = 'force';
			document.getElementById(`load_${i}_2_unit`).dataset.unit = 'force';

			document.getElementById(`load_${i}_3_row`).style.display = '';
			document.getElementById(`load_${i}_3_label`).innerHTML = 'M=';
			document.getElementById(`load_${i}_3`).readOnly = true;
			document.getElementById(`load_${i}_3`).dataset.unit = 'torque';
			document.getElementById(`load_${i}_3_unit`).dataset.unit = 'torque';
			for (j=4;j<=4;j++)
				document.getElementById(`load_${i}_${j}_row`).style.display = 'none';
		} else if (type == 'force' || type == 'moment') {
			document.getElementById(`load_${i}_1_row`).style.display = '';
			document.getElementById(`load_${i}_1_label`).innerHTML = 'At x=';
			document.getElementById(`load_${i}_1`).readOnly = false;
			document.getElementById(`load_${i}_1`).dataset.unit = 'dimension';
			document.getElementById(`load_${i}_1_unit`).dataset.unit = 'dimension';

			document.getElementById(`load_${i}_2_row`).style.display = '';
			document.getElementById(`load_${i}_2_label`).innerHTML = type == 'force' ? 'F=' : 'M=';
			document.getElementById(`load_${i}_2`).readOnly = false;
			document.getElementById(`load_${i}_2`).dataset.unit 	  = type == 'force' ? 'force' : 'torque';
			document.getElementById(`load_${i}_2_unit`).dataset.unit = type == 'force' ? 'force' : 'torque';
			for (j=3;j<=4;j++)
				document.getElementById(`load_${i}_${j}_row`).style.display = 'none';
		} else if (type == 'displacement' || type == 'slope') {
			document.getElementById(`load_${i}_1_row`).style.display = '';
			document.getElementById(`load_${i}_1_label`).innerHTML = 'At x=';
			document.getElementById(`load_${i}_1`).readOnly = false;
			document.getElementById(`load_${i}_1`).dataset.unit = 'dimension';
			document.getElementById(`load_${i}_1_unit`).dataset.unit = 'dimension';

			document.getElementById(`load_${i}_2_row`).style.display = '';
			document.getElementById(`load_${i}_2_label`).innerHTML = type == 'slope' ? 'slope=' : 'y=';
			document.getElementById(`load_${i}_2`).readOnly = false;
			document.getElementById(`load_${i}_2`).dataset.unit = type == 'slope' ? 'slope' : 'deflection';
			document.getElementById(`load_${i}_2_unit`).dataset.unit = type == 'slope' ? 'slope' : 'deflection';


			document.getElementById(`load_${i}_3_row`).style.display = '';
			document.getElementById(`load_${i}_3_label`).innerHTML = type == 'slope' ? 'M=' : 'F=';
			document.getElementById(`load_${i}_3`).readOnly = true;
			document.getElementById(`load_${i}_3`).dataset.unit = type == 'slope' ? 'torque' : 'force';
			document.getElementById(`load_${i}_3_unit`).dataset.unit = type == 'slope' ? 'torque' : 'force';
			for (j=4;j<=4;j++)
				document.getElementById(`load_${i}_${j}_row`).style.display = 'none';
		}
		UNIT_change(); // draw the units
	}

	function removeLoad(load_no) {
		loads = document.getElementById('loads');
		for(i=0; i<loads.children.length-1; i++) {
			if (loads.children[i].dataset.load_id == load_no) {
				loads.removeChild(loads.children[i]);
				i--;
			}
			else { // make them even and odd
				loads.children[i].classList.remove(i%2 ? 'odd' : 'even');
				loads.children[i].classList.add(i%2 ? 'even' : 'odd');
			}
		}
		compute();
	}

	function dumpDynamicPersistence() {
		let loads = document.getElementById('loads');
		let loads_obj = [];

		for(i=0; i<loads.children.length-1; i++) {
			let x = loads.children[i].dataset.load_id;
			loads_obj.push({
				where:  document.getElementById(`load_${x}_1`).value,
				amount: document.getElementById(`load_${x}_2`).value,
				type:   document.getElementById(`load_type_${x}`).selectedIndex
			});
		}

		setLocalStorage('loads', JSON.stringify(loads_obj));
	}

	function loadDynamicPersistence() {
		let loads_obj = JSON.parse(getLocalStorage('loads'));
		for (let load of loads_obj) {
			addLoad(load);
		}
	}

	function populateMaterials() {
		select = document.getElementById('material');

		i=0;
		for(matl in MATERIAL_DATA) {
			i++;
			opt = document.createElement('option');
			opt.innerHTML = matl;
			opt.value = matl;
			select.appendChild(opt);
		}
	}

	function selectMaterial() {
		matl = document.getElementById('material').value;

		document.getElementById('elastic_modulus').readOnly = matl != 'custom';
		document.getElementById('Sf').readOnly 				= matl != 'custom';
		document.getElementById('density').readOnly 		= matl != 'custom';

		if (matl != 'custom') {
			setV('elastic_modulus', MATERIAL_DATA[matl]['Ef']);
			setV('density', MATERIAL_DATA[matl]['density']);
			setV('mass', MATERIAL_DATA[matl]['density']*getV('area')*getV('length'));
			setV('Sf', MATERIAL_DATA[matl]['Sf'] ? MATERIAL_DATA[matl]['Sf'] : '-');
		}

	}

	//la = linearAlgebra();
	function computeStiffnessMatrix(EI, L) {
		var m = math.matrix([ [12,  6*L,   -12,  6*L   ],
							  [6*L, 4*L*L, -6*L, 2*L*L ],
							  [-12, -6*L,  12,   -6*L  ],
							  [6*L, 2*L*L, -6*L, 4*L*L ] ]);
		return math.multiply(m, EI/L/L/L);
	}

	function ppmatrix(M) {
		msg = "";
		for (row of M._data) {
			for (cell of row) {
				msg += cell.toFixed(0) + ',';
			}
			msg += '\n';
		}
		return msg;
	}

	function ensureMatrix(M) { // bandaid; makes sure that input M is a matrix, not a scalar
		if (M._data) return M;
		else return math.matrix([[M]]);
	}

	function stripMatrix(M) { // bandaid; makes input matrix M into a scalar if the matrix is 1x1
		if (M._size == undefined || M._size[0] != 1 || M._size[1] != 1) return M;
		else return M._data[0][0];
	}

	function computeFE(E, I, order, poses, forces, moments, pinned, fixed, displs, slopes) {
		numel = order.length-1;

		numnode = (numel+1)*2;

		var K = math.matrix(math.zeros([numnode,numnode]));
		F = math.matrix(math.zeros([numnode,1]));
		Q = math.matrix(math.zeros([numnode,1]));
		dofs_to_remove = [];
		for (i in forces){
			F.subset(math.index(order.indexOf(parseInt(i))*2,0), forces[i]);
		}
		for (i in moments){
			F.subset(math.index(order.indexOf(parseInt(i))*2+1,0), moments[i]);
		}
		for (i in pinned){
			dofs_to_remove.push(order.indexOf(parseInt(i))*2);
		}
		for (i in fixed){
			dofs_to_remove.push(order.indexOf(parseInt(i))*2);
			dofs_to_remove.push(order.indexOf(parseInt(i))*2+1);
		}
		for (i in displs){
			dofs_to_remove.push(order.indexOf(parseInt(i))*2);
			Q.subset(math.index(order.indexOf(parseInt(i))*2,0), displs[i]);
		}
		for (i in slopes){
			dofs_to_remove.push(order.indexOf(parseInt(i))*2+1);
			Q.subset(math.index(order.indexOf(parseInt(i))*2+1,0), slopes[i]);
		}

		for (i=0;i<numel;i++) {
			idx = math.index(math.range(i*2, i*2+4), math.range(i*2, i*2+4));
			ss = K.subset(idx);
			Ks = computeStiffnessMatrix(E*I, poses[order[i+1]]-poses[order[i]]);
			K.subset(idx,
				math.add(ss, Ks));
		}

		idx_part_k = [];
		idx_part_u = [];
		for (i=0;i<numnode;i++) {
			if (! dofs_to_remove.includes(i)) idx_part_u.push(i);
			else                              idx_part_k.push(i);
		}
		K1 = K.subset(math.index(idx_part_u, idx_part_u));
		K2 = K.subset(math.index(idx_part_u, idx_part_k));
		K3 = K.subset(math.index(idx_part_k, idx_part_u));
		K4 = K.subset(math.index(idx_part_k, idx_part_k));
		Fu = F.subset(math.index(idx_part_u, 0));
		Qk = Q.subset(math.index(idx_part_k, 0));

		Qu = math.multiply(math.inv(K1), math.subtract(Fu, math.multiply(K2, Qk)));
		Fk = math.add(math.multiply(K3, Qu), math.multiply(K4, Qk));
		F.subset(math.index(idx_part_k,0), stripMatrix(Fk));
		F.subset(math.index(idx_part_u,0), stripMatrix(Fu));
		Q.subset(math.index(idx_part_k,0), stripMatrix(Qk));
		Q.subset(math.index(idx_part_u,0), stripMatrix(Qu));
		Qflat = math.flatten(Q)._data;
		Fflat = math.flatten(F)._data;

		channels = {
			x : [], // x, position
			t : [], // theta, angle
			q : [], // q, deflection
			m : [], // m, bending moment
			s : []  // s, shear force
		}
		for (i=0;i<numel;i++) {
			q_seg = Qflat.slice(i*2, i*2+4);
			dl = poses[order[i+1]] - poses[order[i]];
			for (zeta=-1; zeta<1; zeta+=0.05) {
				channels.x.push(poses[order[i]] + (zeta+1)/2*dl);
				channels.t.push(beamShapeFunctionSlope(q_seg, zeta, dl));
				channels.q.push(beamShapeFunction(q_seg, zeta, dl));
				channels.m.push(E*I*beamShapeFunctionCurv(q_seg, zeta, dl));
				channels.s.push(E*I*beamShapeFunctionDcurv(q_seg, zeta, dl));
			}
			zeta = 1;
			channels.x.push(poses[order[i]] + (zeta+1)/2*dl);
			channels.t.push(beamShapeFunctionSlope(q_seg, zeta, dl));
			channels.q.push(beamShapeFunction(q_seg, zeta, dl));
			channels.m.push(E*I*beamShapeFunctionCurv(q_seg, zeta, dl));
			channels.s.push(E*I*beamShapeFunctionDcurv(q_seg, zeta, dl));
		}

		//rxns = math.flatten(math.subset(math.multiply(K, fq), math.index(math.range(0, numnode-1))))._data;

		return [channels, Fflat];
	}

	function beamShapeFunction(arr, zeta, dl) {
		Hfns = [1/4 *Math.pow(1-zeta, 2)*(2+zeta),
				dl/8*Math.pow(1-zeta, 2)*(zeta+1),
				1/4 *Math.pow(1+zeta, 2)*(2-zeta),
				dl/8*Math.pow(1+zeta, 2)*(zeta-1)];
		return math.dot(arr, Hfns);
	}

	function beamShapeFunctionSlope(arr, zeta, dl) {
		Hfns = [3/4*(zeta*zeta-1)*2/dl,
				dl/8*(3*zeta*zeta-2*zeta-1)*2/dl,
				-3/4*(zeta*zeta-1)*2/dl,
				dl/8*(3*zeta*zeta+2*zeta-1)*2/dl];
		return math.dot(arr, Hfns);
	}

	function beamShapeFunctionCurv(arr, zeta, dl) {
		Hfns = [6*zeta/dl/dl,
				(3*zeta-1)/dl,
				-6*zeta/dl/dl,
				(3*zeta+1)/dl];
		/*Hfns = [(4*x-6*dl)/dl/dl/dl,
				(6*x-4*dl)/dl/dl,
				(-12*x+6*dl)/dl/dl/dl,
				(6*x-2*dl)/dl/dl];*/
		return math.dot(arr, Hfns);
	}

	function beamShapeFunctionDcurv(arr, zeta, dl) {
		Hfns = [3/2*Math.pow(2/dl, 3),
				3/4*dl*Math.pow(2/dl, 3),
				-3/2*Math.pow(2/dl, 3),
				3/4*dl*Math.pow(2/dl, 3)];
		/*Hfns = [(4*x-6*dl)/dl/dl/dl,
				(6*x-4*dl)/dl/dl,
				(-12*x+6*dl)/dl/dl/dl,
				(6*x-2*dl)/dl/dl];*/
		return math.dot(arr, Hfns);
	}

	function compute() {
		try{
		selectShape();

		L = getV('length');

		order   = [0,   1]; // node ids, in order (sort later)
		poses   = {0:0, 1:L}; // positions
		forces  = {}; // maps node ids to values
		moments = {}; // maps node ids to values
		pinned  = {}; // if the node id is in the list, it's pinned
		fixed   = {}; // if the node id is in the list, it's pinned
		displs  = {};
		slopes  = {};
		displs_a = {};
		slopes_a = {};

		loads = document.getElementById('loads');
		for(i=2; i<loads.children.length-1+2; i++) {
			x = loads.children[i-2].dataset.load_id;
			type = document.getElementById(`load_type_${x}`).value;

			order.push(i);
			poses[i] = getV(`load_${x}_1`);
			if (type == 'fix') {
				fixed[i] = x;
			} else if (type == 'pin') {
				pinned[i] = x;
			} else if (type == 'force') {
				forces[i] = getV(`load_${x}_2`);
			} else if (type == 'moment') {
				moments[i] = getV(`load_${x}_2`);
			} else if (type == 'displacement') {
				displs[i] = getV(`load_${x}_2`);
				displs_a[i] = x;
			} else if (type == 'slope') {
				slopes[i] = getV(`load_${x}_2`);
				slopes_a[i] = x;
			}
		}

		order.sort(function(a, b){ return poses[a]-poses[b]});

		// merge close nodes
		for (i=0;i<order.length-1;i++) {
			if (Math.abs(poses[order[i]] - poses[order[i+1]]) < L/100) {
				oldnode = order[i];
				newnode = order[i+1]
				order.splice(i, 1);
				if (oldnode in poses) {
					poses[newnode] = poses[oldnode];
					delete poses[oldnode];
				}
				if (oldnode in forces) {
					forces[newnode] = forces[oldnode];
					delete forces[oldnode];
				}
				if (oldnode in moments) {
					moments[newnode] = moments[oldnode];
					delete moments[oldnode];
				}
				if (oldnode in pinned) {
					pinned[newnode] = pinned[oldnode];
					delete pinned[oldnode];
				}
				if (oldnode in fixed) {
					fixed[newnode] = fixed[oldnode];
					delete fixed[oldnode];
				}
				if (oldnode in displs) {
					displs[newnode] = displs[oldnode];
					displs_a[newnode] = displs_a[oldnode];
					delete displs[oldnode];
					delete displs_a[oldnode];
				}
				if (oldnode in slopes) {
					slopes[newnode] = slopes[oldnode];
					slopes_a[newnode] = slopes_a[oldnode];
					delete slopes[oldnode];
					delete slopes_a[oldnode];
				}
			}
		}

		[channels, rxns] = computeFE(getV('moi'), getV('elastic_modulus'),
			order, poses, forces, moments, pinned, fixed, displs, slopes);

		for (pin in pinned) {
			noden = order.indexOf(parseInt(pin));
			setV(`load_${pinned[pin]}_2`, rxns[noden*2]);
		}
		for (fix in fixed) {
			noden = order.indexOf(parseInt(fix));
			setV(`load_${fixed[fix]}_2`, rxns[noden*2]);
			setV(`load_${fixed[fix]}_3`, rxns[noden*2+1]);
		}
		for (dis in displs_a) {
			noden = order.indexOf(parseInt(dis));
			setV(`load_${displs_a[dis]}_3`, rxns[noden*2]);
		}
		for (slo in slopes_a) {
			noden = order.indexOf(parseInt(slo));
			setV(`load_${slopes_a[slo]}_3`, rxns[noden*2+1]);
		}

		// draw the plot
		PLOT_drawLinePlot({
			chartName: "chart",
			axes: {
				x: {
					numTicks: 10,
					boxEnds: false,
					negativeHandling: 'posonly',
					margin: 15
				}, y: {
					numTicks: 7,
					boxEnds: true,
					negativeHandling: 'symmetric',
					margin: 5
				}, z: {
					syncWithY: true,
					margin: 5
				}
			},
			datasets: {
				x: {
					axis: 'x'
				},
				q: {
					axis: 'y'
				},
				m: {
					axis: 'z'
				},
				s: {
					axis: 'z'
				}				
			},
			queries: {
				//INDEX: { places: 0 },
				x: {},
				t: {},
				q: {},
				m: {},
				s: {}
			}
		},
		channels,
		plotClickHandler);

		drawBeam();

		}catch(err){
			console.log(err);
			setError(2, err);
			return;
		}
		setError(0);
		if (EXP_dumpPersistence())
			dumpDynamicPersistence();
	}

	function plotClickHandler(e) {
		let xq = NaN; // pull out a value if the query succeeds
		if(!isNaN(e)) {
			xq = PLOT_focusHandler(document.getElementById("chart"), e);
		} else if (e.buttons==2) {
		} else if (e.target.classList.contains('beam-shape')) { // if clicked on a beam shape, focus on the shape
			if(e.buttons==1)
				xq = PLOT_focusHandler(document.getElementById("chart"), e.target.getAttribute('cp'));
		} else if (e.buttons==1) {
			xq = PLOT_focusHandler(document.getElementById("chart"), e);
		}

		if (!isNaN(xq)) {
			setV("query_stress_shear",     interp1D(channels.x, channels.s, xq)/getV('area'));
			setV("query_stress_bend_top", -interp1D(channels.x, channels.m, xq)*getV('rmax')/getV('moi'));
			setV("query_stress_bend_bot", +interp1D(channels.x, channels.m, xq)*getV('rmin')/getV('moi'));
		}
	}

	function drawBeam() {
		beam = document.getElementById('chart_beam');
		beam_items = document.getElementById('chart_beam_items');
		while(beam_items.firstChild) beam_items.removeChild(beam_items.firstChild);
		x_axis = document.getElementById('chart_x_axis');

		x0 = Math.min(x_axis.x1.baseVal.value, x_axis.x2.baseVal.value);
		xf = Math.max(x_axis.x1.baseVal.value, x_axis.x2.baseVal.value);
		y0 = beam.y1.baseVal.value;
		len = getV('length');
		canv_geo = [x0, xf, y0];

		loads = document.getElementById('loads');

		for(i=0; i<loads.children.length-1; i++) {
			x = loads.children[i].dataset.load_id;
			type = document.getElementById(`load_type_${x}`).value;


			position = getV(`load_${x}_1`);
			cp = x0 + (xf-x0)*position/len;

			if (type == 'fix') {
				shape = document.createElementNS('http://www.w3.org/2000/svg','polyline');
				y2 = y0 + 20;
				x1 = cp - 12;
				x2 = cp + 12;
				shape.classList.add('beam-shape');
				shape.setAttribute('fill', '#111');
				shape.setAttribute('points', `${x2},${y0} ${x1},${y0} ${x1},${y2} ${x2},${y2}`);
				shape.setAttribute('cp', position);
				beam_items.append(shape);
			} else if (type == 'pin') {
				shape = document.createElementNS('http://www.w3.org/2000/svg','polyline');
				y2 = y0 + 20;
				x1 = cp - 10;
				x2 = cp + 10;
				shape.classList.add('beam-shape');
				shape.setAttribute('fill', '#111');
				shape.setAttribute('points', `${cp},${y0} ${x1},${y2} ${x2},${y2}`);
				shape.setAttribute('cp', position);
				beam_items.append(shape);
			} else if (type == 'force') {
				sgn = getV(`load_${x}_2`) < 0 ? -1 : +1;

				shape = document.createElementNS('http://www.w3.org/2000/svg','polyline');
				y2 = y0 - 25*sgn;
				shape.setAttribute('points', `${cp},${y0} ${cp},${y2}`);
				shape.classList.add('beam-arrow');
				shape.setAttribute('stroke', '#111');
				shape.setAttribute('cp', position);
				beam_items.append(shape);

				shape = document.createElementNS('http://www.w3.org/2000/svg','polyline');
				x1 = cp - 12*sgn;
				x2 = cp + 12*sgn;
				y1 = y0 - 25*sgn;
				y2 = y0 - 45*sgn;
				shape.classList.add('beam-shape');
				shape.setAttribute('fill', sgn>0 ? '#1a1' : '#d22');
				shape.setAttribute('points', `${cp},${y2} ${x1},${y1} ${x2},${y1}`);
				shape.setAttribute('cp', position);
				beam_items.append(shape);
			} else if (type == 'moment') {
				sgn = getV(`load_${x}_2`) < 0 ? -1 : +1;

				shape = document.createElementNS('http://www.w3.org/2000/svg','circle');
				shape.classList.add('beam-shape');
				shape.setAttribute('fill', sgn>0 ? '#1a1' : '#d22');
				shape.setAttribute('cx', cp);
				shape.setAttribute('cy', y0);
				shape.setAttribute('r', 12);
				shape.setAttribute('cp', position);
				beam_items.append(shape);
			} else if (type == 'slope') {
				sgn = getV(`load_${x}_2`) < 0 ? -1 : +1;
				shape = document.createElementNS('http://www.w3.org/2000/svg','polyline');
				x1 = cp + 14*sgn;
				y1 = y0 - 14;
				x2 = cp - 14*sgn;
				y2 = y0 + 14;
				shape.setAttribute('points', `${x1},${y1} ${x2},${y2}`);
				shape.setAttribute('stroke', sgn>0 ? '#1a1' : '#d22');
				shape.classList.add('beam-prescribed');
				shape.setAttribute('cp', position);
				beam_items.append(shape);
			} else if (type == 'displacement') {
				sgn = getV(`load_${x}_2`) < 0 ? -1 : +1;
				shape = document.createElementNS('http://www.w3.org/2000/svg','polyline');
				x1 = cp;
				y1 = y0 - 14;
				x2 = cp;
				y2 = y0 + 14;
				shape.setAttribute('points', `${x1},${y1} ${x2},${y2}`);
				shape.setAttribute('stroke', sgn>0 ? '#1a1' : '#d22');
				shape.classList.add('beam-prescribed');
				shape.setAttribute('cp', position);
				beam_items.append(shape);
			}
		}
	}
</script>

<html>

<!-- Make sure to call your init function on document load -->
<!-- You can copy the topbar template here -->
<body onload="init()">
<div id="topbar">
	<div class="topbar-la selectable" onclick="window.location='./'">EveryCalc</div>
	<div class="topbar-la" id='topbar_version'></div>
	<div class="topbar-la" id='topbar_filename'></div>
	<div class="topbar-la" id='topbar_unit'>
		<!-- Required for unit library. You could also put this in the calculator main body -->
		<select id="unit_select" onchange="UNIT_change(); compute();">
			<option value=0 >Metric</option>
			<option value=1 selected="selected">English</option>
		</select>
	</div>
	<div class="topbar-ctr" id="topbar_title">Beam Structural Calc</div>
	<div class="topbar-ra selectable" id="topbar_status"><span></span><span class='ttt'></span></div>
	<div class="topbar-ra selectable" onclick="document.getElementById('section_img').removeAttribute('src'); downloadPage();" id="download">Export HTML</div>
	<div class="topbar-ra selectable" onclick="printPage();">Print</div>
	<div class="topbar-ra selectable" onclick="WALK_enable();">Tutorial</div>
	<a id="download_frame" hidden></a>
</div>	

<svg id="walkthrough_overlay" onclick="WALK_nextStep()" >
	<path id="walkthrough_frame" ></path>
	<text id="walkthrough_text" ></text>
	<text id="walkthrough_skip_button" onclick="WALK_disable();">Skip Tutorial</text>
</svg>

<!-- From here go nuts, do whatever works for you. Use the container to keep stuff from spilling under topbar. I'll point out patterns to pay attention to. -->
	<div style="width: 275px; float: left;" class="container">
		<div class="even">
			<table>
				<tr>
					<th class='rowlabel'>Length</th>
					<td><input id='length' data-unit='dimension' /></td>
					<td class='unit' data-unit='dimension'></td>
				</tr>
			</table>
		</div>
			
		<div class="odd" id="user_input_material">
			<label class="bold rowlabel">Material</label>
			<select id="material" onchange="selectMaterial(); compute();">
				<option value="custom">Custom</option>
			</select>
			<input class="dropdown" type="checkbox" id="toggle-material">
			<label class="dropdown" for="toggle-material">V</label>
			<table id="table_material" class="dropdown">
				<tr>
					<th class='rowlabel'>Flexural Modulus</th>
					<td><input id='elastic_modulus' data-unit='elastic_modulus' value=69 /></td>
					<td class='unit' data-unit='elastic_modulus'></td>
				</tr><tr>
					<th class='rowlabel'>Flexural Strength</th>
					<td><input id='Sf' data-unit='stress' value=30 /></td>
					<td class='unit' data-unit='stress'></td>
				</tr><tr>
					<th class='rowlabel'>Density</th>
					<td><input id='density' data-unit='density' value=0 /></td>
					<td class='unit' data-unit='density'></td>
				</tr><tr>
					<th class='rowlabel'>Mass</th>
					<td><input id='mass' data-unit='mass' readonly /></td>
					<td class='unit' data-unit='mass'></td>
				</tr>
			</table>
		</div>
		<div class="even" id="user_input_section">
			<label class='bold rowlabel'>Cross-Section</label>
			<select id="section" onchange="selectShape(); compute();">
				<option value="rndbar" selected='selected'>Round Bar</option>
				<option value="boxbar">Rect. Bar</option>
				<option value="boxtube">Box Tube</option>
				<option value="channel">Channel</option>
				<option value="rndtube">Round Tube</option>
				<option value="angle">Angle</option>
				<option value="hex">Hexagon</option>
				<option value="custom">Custom</option>
			</select>
			<input class="dropdown" type="checkbox" id="toggle-section">
			<label class="dropdown" for="toggle-section">V</label>
			<table id="table_section" class="dropdown">
				<tr>
					<td colspan=3>
						<center><img id='section_img' /></center>
					</td>
				</tr>
				<tr>
					<th class='rowlabel'>MOI<span class="ttt">The area moment of inertia for the section</span></th>
					<td><input id='moi' data-unit='moi' readonly /></td>
					<td class='unit' data-unit='moi'></td>
				</tr><tr>
					<th class='rowlabel'>Area<span class="ttt">Cross-sectional area</span></th>
					<td><input id='area' data-unit='area' readonly /></td>
					<td class='unit' data-unit='area'></td>
				</tr><tr>
					<th class='rowlabel'>Top Height<span class="ttt">Distance from neutral axis to top of section</span></th>
					<td><input id='rmax' data-unit='dimension' readonly /></td>
					<td class='unit' data-unit='dimension'></td>
				</tr><tr>
					<th class='rowlabel'>Bottom Height<span class="ttt">Distance from neutral axis to bottom of section</span></th>
					<td><input id='rmin' data-unit='dimension' readonly /></td>
					<td class='unit' data-unit='dimension'></td>
				</tr>
			</table><table id="table_section_input">
				<tr id='section_1_row'>
					<th class='rowlabel' id='section_1_label'>D1</th>
					<td><input id='section_1' data-unit='dimension' value=5 /></td>
					<td class='unit' data-unit='dimension'></td>
				</tr><tr id='section_2_row'>
					<th class='rowlabel' id='section_2_label'>D2</th>
					<td><input id='section_2' data-unit='dimension' /></td>
					<td class='unit' data-unit='dimension'></td>
				</tr><tr id='section_3_row'>
					<th class='rowlabel' id='section_3_label'>D3</th>
					<td><input id='section_3' data-unit='dimension' /></td>
					<td class='unit' data-unit='dimension'></td>
				</tr><tr id='section_4_row'>
					<th class='rowlabel' id='section_4_label'>D4</th>
					<td><input id='section_4' data-unit='dimension' /></td>
					<td class='unit' data-unit='dimension'></td>
				</tr><tr id='section_flip_row'>
					<th class='rowlabel' id='section_flip_label'>Flip?</th>
					<td><input type="checkbox" id='section_flip' /></td>
				</tr>
			</table>
		</div>
		<div class="even" id='loads' data-current_load_number=0><center class=""><button id='addLoad_btn' onclick='addLoad()'>Add Load</button><input class="dropdown" type="checkbox" id="toggle_tips"><label class="dropdown" for="toggle_tips" id="toggle_tips_label">Show Tips</label><div class="dropdown">
      <p>Moments are positive counter-clockwise.</p>
      <p>Click on the chart to query points. </p>
      <p>Click on the beam elements to query the corresponding points.</p>
      <p>Right click on the chart near a local extrema to latch on and find the local extrema.</p>
      <p>Moments are positive-counterclockwise.</p>
      <p>Bending/shear extrema are at points of interest (constraints/loads).</p>
      <p>The flexural strength and mass properties are for your usage/reference only- they aren't used in calculations.</p>
    </div></center></div> <!-- MAKE SURE NO SPACES! NO DEAD CHLDREN! -->
	</div>


<div style="margin-left: 0px;" class="container" id="charts">

<style>
	.beam {
		stroke: #555;
		stroke-width: 8px;
	}

	.beam-shape {
		stroke: none;
	}

	.beam-prescribed {
		stroke-width: 3;
	}

	.beam-arrow {
		stroke-width: 3;
	}

	.load {
		border-top: 2px solid #333 !important;
	}
</style>

<svg version="1.2" class="plot" id='chart' aria-labelledby="title" role="img" style="height:600px; width:700px;">
	<rect class="plot-background" id="chart_background" x=70 y=20 width=555 height=430 />
	<g>
	  <line id="chart_x_axis" class="plot-axis" x1=70  x2=625 y1=235 y2=235></line>
	  <line id="chart_y_axis" class="plot-axis" x1=70  x2=70  y1=20  y2=450 ></line>
	  <line id="chart_z_axis" class="plot-axis" x1=625 x2=625 y1=20  y2=450></line>
	</g>

	<!-- non-standard beam stuff -->

	<rect opacity=0 class="plot-background" id="beam_background" x=60 y=500 width=575 height=100 />
	<g class="beam">
	  <line id="chart_beam" class="beam" x1=70 x2=625 y1=550 y2=550 ></line>
	</g>
	<g id="chart_beam_items"></g>

	<g class="plot-grid" id="chart_x_grid"></g>
	<g class="plot-grid" id="chart_y_grid"></g>
	<g class="plot-grid" id="chart_z_grid"></g>

	<g class="plot-labels">
	  <text x="325" y=485 class="plot-titlelabel unit" id="chart_x_label" data-unit='dimension' >Position []</text>

	  <text x=-240 y=15 class="plot-titlelabel unit" transform="rotate(270)" id="chart_q_label" data-unit='deflection' fill="#0074d9">Deflection []</text>

	  <text x=-120 y=700 class="plot-titlelabel unit" transform="rotate(270)" id="chart_m_label" data-unit='torque' fill="#d91200">Bending Moment []</text>
	  <text x=-240 y=700 class="plot-titlelabel" transform="rotate(270)" fill="#111">/</text>
	  <text x=-320 y=700 class="plot-titlelabel unit" transform="rotate(270)" id="chart_s_label" data-unit='force' fill="#c48900">Shear Force []</text>
	</g>

	<g class="plot-axlabels" id='chart_x_axlabels'></g>
	<g class="plot-axlabels" id='chart_z_axlabels'></g>
	<g class="plot-axlabels" id='chart_y_axlabels'></g>

	<g>
		<line class="plot-querybar" id="chart_querybar" x1=100 x2=100 y1=15 y2=555 opacity=0></line>
	</g>
	<polyline
		id='chart_q_line'
		fill='none'
		stroke='#0074d9'
		stroke-width=2
		points="
		"/>
	<polyline
		id='chart_m_line'
		fill='none'
		stroke='#d91200'
		stroke-width=2
		points="
		"/>
	<polyline
		id='chart_s_line'
		fill='none'
		stroke='#c48900'
		stroke-width=2
		points="
		"/>

	<rect id="chart_query_area" x=0 y=0 width=700 height=460 opacity=0 fill="#fff">
</svg>

	<div class="output-plot" id ="chart_querytable" style='display:none;'>
		<table>
			<tr>
				<th class="rowlabel">Queried Position<span class="ttt">Query a position on the graph by clicking (and optionally dragging) a point.</span></th>
				<td><input id="chart_x" data-unit='dimension' onchange="plotClickHandler(getV('chart_x'));" /></td>
				<td class="unit" data-unit='dimension'></td>
			</tr><tr>
				<th class="rowlabel">Deflection</th>
				<td><input id="chart_q" data-unit='deflection' readonly /></td>
				<td class="unit" data-unit='deflection'></td>
				<th class="rowlabel">Slope</th>
				<td><input id="chart_t" data-unit='slope' readonly /></td>
				<td class="unit" data-unit='slope'></td>
			</tr><tr>
				<th class="rowlabel">Bending Moment</th>
				<td><input id="chart_m" data-unit='torque' readonly /></td>
				<td class="unit" data-unit='torque'></td>
				<th class="rowlabel">Bending Stress @ Top/Bottom<span class="ttt">Positive is tension</span></th>
				<td><input id="query_stress_bend_top" data-unit='stress' readonly /></td>
				<td><input id="query_stress_bend_bot" data-unit='stress' readonly /></td>
				<td class="unit" data-unit='stress'></td>
			</tr><tr>
				<th class="rowlabel">Shear Force<span class="ttt">Note: Shear force at a load/constraint is not properly defined. Query before and after.</span></th>
				<td><input id="chart_s" data-unit='force' readonly /></td>
				<td class="unit" data-unit='force'></td>
				<th class="rowlabel">Shear Stress @ Center</th>
				<td><input id="query_stress_shear" data-unit='stress' readonly /></td>
				<td class="unit" data-unit='stress'></td>
			</tr>
		</table>
	</div>

</div>
</body>
</html>
