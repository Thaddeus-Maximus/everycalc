<!DOCTYPE html>
<link rel="stylesheet" href="include/style.css"> 
<script type="text/javascript" src="include/specs.js"></script>
<script type="text/javascript" src="include/math.js"></script>
<script type="text/javascript">
	unit_sys = 0;
	inputs_unit_map = {
		'force':           ['N', 'lbf'],
		'elastic_modulus': ['GPa', '10^6 psi'],
		'moi':       ['mm^4', 'in^4'],
		'area': 	 ['mm^2', 'in^2'],
		'section_1': ['mm', 'in'],
		'section_2': ['mm', 'in'],
		'section_3': ['mm', 'in'],
		'section_4': ['mm', 'in'],
		'length':    ['mm', 'in'],
		'rmax':      ['mm', 'in'],
		'rmin':      ['mm', 'in'],
		'query_l':   ['mm', 'in'],
		'query_q':   ['mm', 'thou'],
		'query_m':   ['N-m', 'ft-lbf'],
		'query_sl':  ['deg', 'deg'],
		'query_sh':  ['N', 'lbf'],
		'query_stress_bend_top': ['MPa', 'psi'],
		'query_stress_bend_bot': ['MPa', 'psi'],
		'query_stress_shear':    ['MPa', 'psi'],
		'density': ['g/cm^3', 'lbm/in^3'],
		'mass':    ['kg',  'lbm'],
		'Sf':      ['MPa', 'psi']

	}

	function switch_units() {
		if(document.getElementById('unit_metric').checked)
			unit_sys = 0;
		else 
			unit_sys = 1;

		unit_labels = document.getElementsByClassName('unit');
		for (unit in unit_labels) {
			if (unit_labels[unit].id && inputs_unit_map[unit_labels[unit].id.substring(5)] ){
				varname = unit_labels[unit].id.substring(5);
				document.getElementById('unit_'+varname).innerHTML = '['+inputs_unit_map[varname][unit_sys]+']';
			}
		}

		document.getElementById('chart_q_label').innerHTML = `Deflection [${inputs_unit_map["query_q"][unit_sys]}]`;
		document.getElementById('chart_m_label').innerHTML = `Bending Moment [${inputs_unit_map["query_m"][unit_sys]}]`;
		document.getElementById('chart_x_label').innerHTML = `Position [${inputs_unit_map["query_l"][unit_sys]}]`;
	}

	var poschart = null, poschart_options = null;

	function gidv(id) {
		v =  eval(document.getElementById(id).value);
		if (typeof inputs_unit_map[id] !== 'undefined')
			v = convert(v, inputs_unit_map[id][unit_sys]);
		return v;
	}

	function gids(id, value, places) {
		if (typeof places === 'undefined')
			places = 3;
		if (typeof value === 'string') {
			document.getElementById(id).value = value;
		} else {
			if (typeof inputs_unit_map[id] !== 'undefined')
				value = convert_to(value, inputs_unit_map[id][unit_sys]);
			document.getElementById(id).value = value.toFixed(places);
		}
	}

	function input_callback(e) {
    	var key = e.keyCode ? e.keyCode : e.which;

    	if (key==13) {
    		compute(true);
    	} else {
    		compute(false);
    	}
    }

	function register_callbacks() {
		var inputs, index;
		inputs = document.getElementsByTagName('input');
		for (index = 0; index < inputs.length; ++index) {
			if (inputs[index].id.startsWith('query_')) continue;
		    inputs[index].onkeyup = input_callback;
		    inputs[index].onchange = input_callback;
		}
	}

	function thload() {
		switch_units();

		populate_materials();
		document.getElementById('material').value = 'Aluminum';
		select_material();

		add_load({where: 10, amount: 0, type: 0});
		add_load({where: 50, amount: 0, type: 0});
		add_load({where: 90, amount: 100, type: 2});
		add_load({where: 10, amount: -10, type: 3});
		document.getElementById('length').value=100;
		shape_select();		
		moi_compute();
		
		register_callbacks();

		compute();
	}

		
	function sign(x) {
		if (x>0) return 1;
		if (x<0) return -1;
		return 0;
	}


	function NaNtoerr(x) {
		if (isNaN(x)) return '-'; return x;
	}


	function NaNto1(x) {
		if (isNaN(x))
			return 1;
		return x;
	}

	function collapse(id) {
		tbl = document.getElementById('table_'+id);

		btn = document.getElementById('toggle_detail_'+id);
		if(tbl.rows[1].style['display'] != 'none') {
			for(i=1;i<tbl.rows.length;i++) tbl.rows[i].style['display'] = 'none';
			btn.innerHTML = "&#9660";
		} else {
			for(i=1;i<tbl.rows.length;i++) tbl.rows[i].style['display'] = 'table-row';
			btn.innerHTML = "&#9650";
		}
	}

	function moi_compute() {
		invalidate_computations();
		shape = document.getElementById('section').value;
		var moi, area, rmax, rmin;
		flip = document.getElementById('section_flip').checked;
		// TODO: unsupported sections
		if (shape == 'rndbar') {
			d = gidv('section_1');
			rmax = rmin = d/2;
			area = Math.PI/4 * d*d;
			moi = Math.PI/64*Math.pow(d,4);
		} else if (shape == 'boxbar') {
			w = gidv('section_1');
			h = gidv('section_2');
			rmax = rmin = h/2;
			area = w*h;
			moi = w*Math.pow(h,3)/12;
		} else if (shape == 'boxtube') {
			w = gidv('section_1');
			h = gidv('section_2');
			t = gidv('section_3');
			rmax = rmin = h/2;
			area = w*h - (w-2*t)*(w-2*t);
			moi = (w*Math.pow(h,3) - (w-2*t)*Math.pow(h-2*t,3))/12;
		} else if (shape == 'angle') {
			a = gidv('section_1');
			b = gidv('section_2');
			t = gidv('section_3');
			d = b - t;
			c = a - t;
			rmin = (t*(2*d+a)+d*d)/2/(d+a);
			rmax = b-rmin;
			area = a*b - c*d;
			moi  = 1/3*(t*Math.pow(rmax, 3)+ a*Math.pow(b-rmax,3 ) - (a-t)*Math.pow(b-rmax-t, 3));
			if(flip) {
				tmp  = rmax;
				rmax = rmin;
				rmin = tmp;
			}
		} else if (shape == 'channel') {
			b = gidv('section_1');
			d = gidv('section_2');
			t = gidv('section_3');
			s = t;
			h = d-2*s;
			area = 2*s*b + h*t
			if(flip) {
				rmin = (2*b*b*s + h*t*t)/(2*b*d-2*h*(b-t));
				rmax = b - rmin;
				moi  = (2*s*b*b*b + h*t*t*t)/3 - area*rmin*rmin;
			} else {
				rmin = rmax = d/2;
				moi  = (b*d*d*d - h*h*h*(b-t))/12;
			}
		} else if (shape == 'rndtube') {
			d = gidv('section_1');
			t = gidv('section_2');
			rmax = rmin = d/2;
			area = Math.PI/4 * (d*d-(d-2*t)*(d-2*t));
			moi = Math.PI/64*(Math.pow(d,4)-Math.pow(d-2*t,4));
		} else if (shape == 'hex') {
			a = gidv('section_1')/2; //side length
			id = gidv('section_2');
			if (isNaN(id)) id = 0;
			area = Math.sqrt(3)*3/2*a*a 			- Math.PI/4 * id*id;
			moi  = 5/16*Math.sqrt(3)*Math.pow(a, 4) - Math.PI/64*Math.pow(id,4);
			rmax = rmin = flip ? a : (a*2/Math.sqrt(3));
		}

		if (shape != 'custom') {
			gids("moi", moi);
			gids("area", area);
			gids("rmax", rmax);
			gids("rmin", rmin);
		} 
		
	}

	function shape_select(disable_recompute) {
		if(!disable_recompute) invalidate_computations();
		shape = document.getElementById('section').value;
		document.getElementById('moi').readOnly = true;
		document.getElementById('area').readOnly = true;
		document.getElementById('rmax').readOnly = true;
		document.getElementById('rmin').readOnly = true;
		document.getElementById('section_img').src = 'include/section_' + shape + '.svg';
		if (shape == 'custom') {
			document.getElementById('moi').readOnly  = false;
			document.getElementById('area').readOnly = false;
			document.getElementById('rmax').readOnly = false;
			document.getElementById('rmin').readOnly = false;
			document.getElementById('section_flip_row').style.display = 'none';
			for (i=1;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'rndbar') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Diameter';
			document.getElementById('section_flip_row').style.display = 'none';
			for (i=2;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'boxbar') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Width';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'Height';
			document.getElementById('section_flip_row').style.display = 'none';
			for (i=3;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'boxtube') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Width';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'Height';
			document.getElementById('section_3_row').style.display = '';
			document.getElementById('section_3_label').innerHTML = 'Thickness';
			document.getElementById('section_flip_row').style.display = 'none';
			for (i=4;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'channel') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Width';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'Height';
			document.getElementById('section_3_row').style.display = '';
			document.getElementById('section_3_label').innerHTML = 'Thickness';
			document.getElementById('section_flip_row').style.display = '';
			document.getElementById('section_flip_label').innerHTML = 'Rotate 90?';
			for (i=4;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'angle') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Width';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'Height';
			document.getElementById('section_3_row').style.display = '';
			document.getElementById('section_3_label').innerHTML = 'Thickness';
			document.getElementById('section_flip_row').style.display = '';
			document.getElementById('section_flip_label').innerHTML = 'Flip 180?';
			for (i=4;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'rndtube') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'OD';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'Thickness';
			document.getElementById('section_flip_row').style.display = 'none';
			for (i=3;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} else if (shape == 'hex') {
			document.getElementById('section_1_row').style.display = '';
			document.getElementById('section_1_label').innerHTML = 'Width';
			document.getElementById('section_2_row').style.display = '';
			document.getElementById('section_2_label').innerHTML = 'ID';
			document.getElementById('section_flip_row').style.display = '';
			document.getElementById('section_flip_label').innerHTML = 'Rotate 90?';
			for (i=3;i<=4;i++)
				document.getElementById('section_'+i+'_row').style.display = 'none';
		} 
		if (!disable_recompute) {
			moi_compute();
			select_material();
		}
	}

	var current_load_number = 0;
	function add_load(params) {
		invalidate_computations();
		loads = document.getElementById('loads');
		load_div = document.createElement('div');
		x = current_load_number;
		current_load_number ++;
		load_div.innerHTML = `
		<table>
			<tr>
				<td>[${x}] <button onclick="remove_load(${x}); compute();" title="Remove">-</button></td>
				<td><select id="load_type_${x}" onchange="change_load(${x}); compute();">
					<option value="pin" selected='selected' >Pinned</option>
					<option value="fix">Fixed</option>
					<option value="force">Force </option>
					<option value="moment">Moment</option>
				</select></td>
			</tr>
			<tr id="load_${x}_1_row">
				<th class="rowlabel" id="load_${x}_1_label">L1</th>
				<td><input id="load_${x}_1" onchange="drawbeam()"/></td>
				<td class="unit" id="unit_load_${x}_1"></td>
			</tr><tr id="load_${x}_2_row">
				<th class="rowlabel" id="load_${x}_2_label">L2</th>
				<td><input id="load_${x}_2" onchange="drawbeam()" /></td>
				<td class="unit" id="unit_load_${x}_2"></td>
			</tr><tr id="load_${x}_3_row">
				<th class="rowlabel" id="load_${x}_3_label">L3</th>
				<td><input id="load_${x}_3" onchange="drawbeam()" /></td>
				<td class="unit" id="unit_load_${x}_3"></td>
			</tr><tr id="load_${x}_4_row">
				<th class="rowlabel" id="load_${x}_4_label">L4</th>
				<td><input id="load_${x}_4" onchange="drawbeam()" /></td>
				<td class="unit" id="unit_load_${x}_4"></td>
			</tr>
		</table>
	`;
		load_div.identifier = x;
		load_div.classList.add(x%2 ? 'even' : 'odd');
		load_div.classList.add('load');
		loads.insertBefore(load_div, loads.lastChild);

		if (typeof params != 'undefined') {
			document.getElementById(`load_${x}_1`).value = params.where;
			document.getElementById(`load_${x}_2`).value = params.amount;
			document.getElementById(`load_type_${x}`).selectedIndex = params.type;
		}
		change_load(x);
		register_callbacks();
	}

	function change_load(i) {
		invalidate_computations();
		type = document.getElementById('load_type_'+i).value;
		if (type == 'pin' || type == 'fix') {
			document.getElementById(`load_${i}_1_row`).style.display = '';
			document.getElementById(`load_${i}_1_label`).innerHTML = 'At x=';
			inputs_unit_map[`load_${i}_1`] = ['mm', 'in'];
			for (j=2;j<=4;j++)
				document.getElementById(`load_${i}_${j}_row`).style.display = 'none';
		} else if (type == 'force' || type == 'moment') {
			document.getElementById(`load_${i}_1_row`).style.display = '';
			document.getElementById(`load_${i}_1_label`).innerHTML = 'At x=';
			document.getElementById(`load_${i}_2_row`).style.display = '';
			document.getElementById(`load_${i}_2_label`).innerHTML = type == 'force' ? 'F=' : 'M=';
			inputs_unit_map[`load_${i}_1`] = ['mm', 'in'];
			inputs_unit_map[`load_${i}_2`] = type == 'force' ? ['N', 'lbf'] : ['N-m', 'ft-lbf'];
			for (j=3;j<=4;j++)
				document.getElementById(`load_${i}_${j}_row`).style.display = 'none';
		}
		switch_units();
	}

	function remove_load(load_no) {
		loads = document.getElementById('loads');
		for(i=0; i<loads.children.length-1; i++) {
			if (loads.children[i].identifier == load_no) {
				loads.removeChild(loads.children[i]);
				i--;
			}
			else { // make them even and odd
				loads.children[i].classList.remove(i%2 ? 'odd' : 'even');
				loads.children[i].classList.add(i%2 ? 'even' : 'odd');
			}
		}
		compute();
	}

	function populate_materials() {
		select = document.getElementById('material');

		i=0;
		for(matl in materials) {
			i++;
			opt = document.createElement('option');
			opt.innerHTML = matl;
			opt.value = matl;
			select.appendChild(opt);
		}
	}

	function select_material() {
		matl = document.getElementById('material').value;

		document.getElementById('elastic_modulus').readOnly = matl != 'custom';
		document.getElementById('Sf').readOnly 				= matl != 'custom';
		document.getElementById('density').readOnly 		= matl != 'custom';

		if (matl != 'custom') {
			gids('elastic_modulus', materials[matl]['Ef']);
			gids('density', materials[matl]['density']);
			gids('mass', materials[matl]['density']*gidv('area')*gidv('length'));
			gids('Sf', materials[matl]['Sf'] ? materials[matl]['Sf'] : '-');
		}
		
	}
</script>

<script type="text/javascript">
	//la = linearAlgebra();
	function make_stiffness_matrix(EI, L) {
		var m = math.matrix([ [12,  6*L,   -12,  6*L   ],
							  [6*L, 4*L*L, -6*L, 2*L*L ],
							  [-12, -6*L,  12,   -6*L  ],
							  [6*L, 2*L*L, -6*L, 4*L*L ] ]);
		return math.multiply(m, EI/L/L/L);
	}

	function drawtbl(K) {
		tbl = document.getElementById('k_table');
		tbl.innerHTML = '';
		for (i=0;i<K._data.length;i++) {
			tr = tbl.insertRow();
			for (j=0;j<K._data[i].length;j++) {
				td = tr.insertCell(tr.cells.length);
				td.innerHTML = K._data[i][j];
			}
		}
	}

	function run_fe(E, I, order, poses, forces, moments, pinned, fixed) {
		numel = order.length-1;

		numnode = (numel+1)*2;
		
		var K = math.matrix(math.zeros([numnode,numnode]));
		F = math.matrix(math.zeros([numnode,1]));
		dofs_to_remove = [];
		for (i in forces){
			F.subset(math.index(order.indexOf(parseInt(i))*2,0), forces[i]);
		}
		for (i in moments){
			F.subset(math.index(order.indexOf(parseInt(i))*2+1,0), moments[i]);
		}
		for (i in pinned){
			dofs_to_remove.push(order.indexOf(parseInt(i))*2);
		}
		for (i in fixed){
			dofs_to_remove.push(order.indexOf(parseInt(i))*2);
			dofs_to_remove.push(order.indexOf(parseInt(i))*2+1);
		}

		for (i=0;i<numel;i++) {
			idx = math.index(math.range(i*2, i*2+4), math.range(i*2, i*2+4));
			ss = K.subset(idx);
			Ks = make_stiffness_matrix(E*I, poses[order[i+1]]-poses[order[i]]);
			K.subset(idx,
				math.add(ss, Ks));
		}

		idx_rmv_l = [];
		for (i=0;i<numnode;i++) {
			if (! dofs_to_remove.includes(i)) idx_rmv_l.push(i);
		}
		idx_rmv = math.index(idx_rmv_l, idx_rmv_l);
		K = K.subset(idx_rmv);
		F = F.subset(math.index(idx_rmv_l, 0));
		q = math.multiply(math.inv(K), F);
		fq = [];
		offs = 0;
		for (i=0;i<numnode;i++) {
			if (dofs_to_remove.includes(i)){fq.push(0); offs++}
			else fq.push(q._data[i-offs][0]);
		}
		
		xp = []; // x; position
		tp = []; // theta; angle
		qp = []; // q; deflection
		mp = []; // m; bending moment
		sp = []; // s; shear force
		for (i=0;i<numel;i++) {
			q_seg = fq.slice(i*2, i*2+4);
			dl = poses[order[i+1]] - poses[order[i]];
			for (zeta=-1; zeta<1; zeta+=0.05) {
				xp.push(poses[order[i]] + (zeta+1)/2*dl);
				tp.push(beam_shape_fcn_slope(q_seg, zeta, dl));
				qp.push(beam_shape_fcn(q_seg, zeta, dl));
				mp.push(E*I*beam_shape_fcn_curv(q_seg, zeta, dl));
				sp.push(E*I*beam_shape_fcn_dcurv(q_seg, zeta, dl));
			}
			zeta = 1;
			xp.push(poses[order[i]] + (zeta+1)/2*dl);
			tp.push(beam_shape_fcn_slope(q_seg, zeta, dl));
			qp.push(beam_shape_fcn(q_seg, zeta, dl));
			mp.push(E*I*beam_shape_fcn_curv(q_seg, zeta, dl));
			sp.push(E*I*beam_shape_fcn_dcurv(q_seg, zeta, dl));
		}

		return [xp, qp, tp, mp, sp];
	}

	function beam_shape_fcn(arr, zeta, dl) {
		Hfns = [1/4 *Math.pow(1-zeta, 2)*(2+zeta),
				dl/8*Math.pow(1-zeta, 2)*(zeta+1),
				1/4 *Math.pow(1+zeta, 2)*(2-zeta),
				dl/8*Math.pow(1+zeta, 2)*(zeta-1)];
		return math.dot(arr, Hfns);
	}

	function beam_shape_fcn_slope(arr, zeta, dl) {
		Hfns = [3/4*(zeta*zeta-1)*2/dl,
				dl/8*(3*zeta*zeta-2*zeta-1)*2/dl,
				-3/4*(zeta*zeta-1)*2/dl,
				dl/8*(3*zeta*zeta+2*zeta-1)*2/dl];
		return math.dot(arr, Hfns);
	}

	function beam_shape_fcn_curv(arr, zeta, dl) {
		Hfns = [6*zeta/dl/dl,
				(3*zeta-1)/dl,
				-6*zeta/dl/dl,
				(3*zeta+1)/dl];
		/*Hfns = [(4*x-6*dl)/dl/dl/dl,
				(6*x-4*dl)/dl/dl,
				(-12*x+6*dl)/dl/dl/dl,
				(6*x-2*dl)/dl/dl];*/
		return math.dot(arr, Hfns);
	}

	function beam_shape_fcn_dcurv(arr, zeta, dl) {
		Hfns = [3/2*Math.pow(2/dl, 3),
				3/4*dl*Math.pow(2/dl, 3),
				-3/2*Math.pow(2/dl, 3),
				3/4*dl*Math.pow(2/dl, 3)];
		/*Hfns = [(4*x-6*dl)/dl/dl/dl,
				(6*x-4*dl)/dl/dl,
				(-12*x+6*dl)/dl/dl/dl,
				(6*x-2*dl)/dl/dl];*/
		return math.dot(arr, Hfns);
	}

	function invalidate_computations() {
		document.getElementById('charts').classList.add('error');
	}

	function compute() {
		shape_select();

		L = gidv('length');

		invalidate_computations();

		order   = [0,   1]; // node ids, in order (sort later)
		poses   = {0:0, 1:L}; // positions
		forces  = {}; // maps node ids to values
		moments = {}; // maps node ids to values
		pinned  = {}; // if the node id is in the list, it's pinned
		fixed   = {}; // if the node id is in the list, it's pinned

		loads = document.getElementById('loads');
		for(i=2; i<loads.children.length-1+2; i++) {
			x = loads.children[i-2].identifier;
			type = document.getElementById(`load_type_${x}`).value;
			
			order.push(i);
			poses[i] = gidv(`load_${x}_1`);
			if (type == 'fix') {
				fixed[i] = 1;
			} else if (type == 'pin') {
				pinned[i] = 1;
			} else if (type == 'force') {
				forces[i] = gidv(`load_${x}_2`);
			} else if (type == 'moment') {
				moments[i] = gidv(`load_${x}_2`);
			}
		}

		order.sort(function(a, b){ return poses[a]-poses[b]});

		// merge close nodes
		for (i=0;i<order.length-1;i++) {
			if (Math.abs(poses[order[i]] - poses[order[i+1]]) < L/100) {
				oldnode = order[i];
				newnode = order[i+1]
				order.splice(i, 1);
				if (oldnode in poses) {
					poses[newnode] = poses[oldnode];
					delete poses[oldnode];
				}
				if (oldnode in forces) {
					forces[newnode] = forces[oldnode];
					delete forces[oldnode];
				}
				if (oldnode in moments) {
					moments[newnode] = moments[oldnode];
					delete moments[oldnode];
				}
				if (oldnode in pinned) {
					pinned[newnode] = pinned[oldnode];
					delete pinned[oldnode];
				}
				if (oldnode in fixed) {
					fixed[newnode] = fixed[oldnode];
					delete fixed[oldnode];
				}
			}
		}

		displ = run_fe(gidv('moi'), gidv('elastic_modulus'),
			order, poses, forces, moments, pinned, fixed);

		drawchart(displ, [poses, forces, moments, pinned, fixed]);


		document.getElementById('charts').classList.remove('error');
	}
</script>

<script>
	function makeTicks(mins, maxes, num_to_print, n) {
		all_positive = !(mins);
		H = [];
		bases = [];
		for(var i=0; i<maxes.length; i++){
			h = maxes[i]/n;
			if (!all_positive)
				h = (Math.max(-mins[i], maxes[i]))/n;
			base = Math.floor(Math.log10(h)-Math.log10(5));
			bases.push(base);
			H.push(Math.round(h/Math.pow(10, base))*Math.pow(10, base));
		}

		ticks = [];
		ticksstr = [];
		alive = true;
		for(var i=0; alive; i++) {
			alive = false;
			labelstr = '';
			for(var j=0; j<maxes.length; j++) {
				if (j<num_to_print) {
					if (ticks.length <= j+1)
						ticks.push([]);
					ticks[j].push(H[j]*i);
					labelstr += (H[j]*i).toFixed(bases[j] > 0 ? 0:-bases[j]);
					if (j != num_to_print-1)
						labelstr += ' / ';
				}
				if (H[j]*(i) < (all_positive ? maxes[j] : Math.max(maxes[j], -mins[j]) ))
					alive = true;
			}
			ticksstr.push(labelstr);

			if(all_positive || i==0) continue;

			labelstr = '';
			for(var j=0; j<maxes.length; j++) {
				if (j<num_to_print) {
					if (ticks.length <= j+1)
						ticks.push([]);
					ticks[j].unshift(-H[j]*i);
					labelstr += '- ' + (H[j]*i).toFixed(bases[j] > 0 ? 0:-bases[j]);
					if (j != num_to_print-1)
						labelstr += ' / ';
				}
			}
			ticksstr.unshift(labelstr);
			
		}
		return [ticks, ticksstr];
	}

	function sign(x) {
		if(x>0) return 1;
		if(x<0) return -1;
		return 0;
	}

	chart_name = 'chart';

	function drawTicks(axis, ticks, maxtick, ticklabels, ff, f0, gf, g0, marg) {
		altaxis = axis == 'x' ? 'y':'x';
		realaxis = axis == 'z' ? 'y':axis;
		xgrid = document.getElementById(chart_name+'_'+axis+'_grid');
		while(xgrid.firstChild) xgrid.removeChild(xgrid.firstChild);

		labels = document.getElementById(chart_name+'_'+axis+'_axis_labels');
		while(labels.firstChild) labels.removeChild(labels.firstChild);

		gfl = (axis=='z'?gf:g0) + (axis=='y'?-1:1)*marg;

		for (i in ticklabels) {
			line = document.createElementNS('http://www.w3.org/2000/svg','line');
			line.setAttribute(altaxis+'1', gf); line.setAttribute(altaxis+'2', g0);
			fp = f0 + (ff-f0)*(ticks==null ? i/(ticklabels.length-1) : ticks[i]/maxtick);
			line.setAttribute(realaxis+'1', fp);
			line.setAttribute(realaxis+'2', fp);
			line.setAttribute('class', 'grid');
			xgrid.append(line);

			label = document.createElementNS('http://www.w3.org/2000/svg','text');
			label.setAttribute(altaxis, gfl);
			label.setAttribute(realaxis, fp);
			label.innerHTML = ticklabels[i];
			labels.append(label);
		}
	}

	function linterp_idx(xs, xq) {
		for (i=1; i<xs.length-1 && !isNaN(xs[i]) && xq>xs[i]; i++) {}
		return i;
	}

	function linterp(xs, ys, xq) {
		for (i=1; i<xs.length-1 && !isNaN(xs[i]) && xq>xs[i]; i++) {}
		return ys[i-1] + (ys[i]-ys[i-1])/(xs[i]-xs[i-1])*(xq-xs[i-1]);
	}

	function makept(canv_geo, xq, yq) {
		[x0, xf, xl, y_ctr] = canv_geo;
		var pt = svg.createSVGPoint();
		pt.x = x0 + (xf-x0)/xl*xq;
		pt.y = y0 + (yf-y0)/(ym-0)*yq;
		return pt;
	}

	function drawbeam() {

		beam = document.getElementById('chart_beam');
		beam_items = document.getElementById('chart_beam_items');
		while(beam_items.firstChild) beam_items.removeChild(beam_items.firstChild);
		y_axis = document.getElementById('chart_y_axis');

		x0 = Math.min(y_axis.x1.baseVal.value, y_axis.x2.baseVal.value);
		xf = Math.max(y_axis.x1.baseVal.value, y_axis.x2.baseVal.value);
		y0 = beam.y1.baseVal.value;
		len = gidv('length');
		canv_geo = [x0, xf, y0];

		loads = document.getElementById('loads');

		for(i=0; i<loads.children.length-1; i++) {
			x = loads.children[i].identifier;
			type = document.getElementById(`load_type_${x}`).value;
			
			
			position = gidv(`load_${x}_1`);
			cp = x0 + (xf-x0)*position/len;

			subhandler = function (event) {
				focus_handler(event.target.getAttribute('cp'));
			}

			if (type == 'fix') {
				shape = document.createElementNS('http://www.w3.org/2000/svg','polyline');
				y2 = y0 + 20;
				x1 = cp - 12;
				x2 = cp + 12;
				shape.classList.add('beam-shape');
				shape.setAttribute('fill', '#111');
				shape.setAttribute('points', `${x2},${y0} ${x1},${y0} ${x1},${y2} ${x2},${y2}`);
				shape.addEventListener('click', subhandler);
				shape.setAttribute('cp', position);
				beam_items.append(shape);
			} else if (type == 'pin') {
				shape = document.createElementNS('http://www.w3.org/2000/svg','polyline');
				y2 = y0 + 20;
				x1 = cp - 10;
				x2 = cp + 10;
				shape.classList.add('beam-shape');
				shape.setAttribute('fill', '#111');
				shape.setAttribute('points', `${cp},${y0} ${x1},${y2} ${x2},${y2}`);
				shape.addEventListener('click', subhandler);
				shape.setAttribute('cp', position);
				beam_items.append(shape);
			} else if (type == 'force') {
				sgn = gidv(`load_${x}_2`) < 0 ? -1 : +1;

				shape = document.createElementNS('http://www.w3.org/2000/svg','polyline');
				y2 = y0 - 25*sgn;
				shape.setAttribute('points', `${cp},${y0} ${cp},${y2}`);
				shape.classList.add('beam-arrow');
				shape.setAttribute('stroke', '#111');
				shape.addEventListener('click', subhandler);
				shape.setAttribute('cp', position);
				beam_items.append(shape);

				shape = document.createElementNS('http://www.w3.org/2000/svg','polyline');
				x1 = cp - 12*sgn;
				x2 = cp + 12*sgn;
				y1 = y0 - 25*sgn;
				y2 = y0 - 45*sgn;
				shape.classList.add('beam-shape');
				shape.setAttribute('fill', sgn>0 ? '#3c3' : '#d22');
				shape.setAttribute('points', `${cp},${y2} ${x1},${y1} ${x2},${y1}`);
				shape.addEventListener('click', subhandler);
				shape.setAttribute('cp', position);
				beam_items.append(shape);
			} else if (type == 'moment') {
				sgn = gidv(`load_${x}_2`) < 0 ? -1 : +1;

				shape = document.createElementNS('http://www.w3.org/2000/svg','circle');
				shape.classList.add('beam-shape');
				shape.setAttribute('fill', sgn>0 ? '#3c3' : '#d22');
				shape.setAttribute('cx', cp);
				shape.setAttribute('cy', y0);
				shape.setAttribute('r', 12);
				shape.addEventListener('click', subhandler);
				shape.setAttribute('cp', position);
				beam_items.append(shape);
			}
		}
	}

	var focus_l, focus_q, focus_m, focus_sl, focus_sh, focus_xf, focus_x0, focus_l_max;
	var last_lq;
	function focus_handler(event, disable_position_write){
		var xq, lq;
		query_l_unit = inputs_unit_map['query_l'][unit_sys];
		if (!isNaN(event)) {
			lq = parseFloat(event);
			xq = x0 + (xf-x0)*lq/len;
		}else{
			if(event.buttons != 1) return;
			bg = document.getElementById('chart');
			xq = event.clientX - bg.getBoundingClientRect().left;
			//yq = event.clientY - bg.getBoundingClientRect().top;

			lq = (convert(focus_l_max, query_l_unit)-0)/(focus_xf-focus_x0)*(xq-focus_x0);
			if (lq > Math.max(...focus_l)){
				lq = Math.max(...focus_l);
				xq = focus_x0 + (focus_xf-focus_x0)/(convert(focus_l_max, query_l_unit)-0)*lq;
			}
			if (lq<0) {
				lq=0; xq=focus_x0;
			}
		}
			
		qq   = linterp(focus_l, focus_q, lq);
		mq   = linterp(focus_l, focus_m, lq);
		slq  = linterp(focus_l, focus_sl, lq);
		shq  = linterp(focus_l, focus_sh, lq);
		qline.setAttribute('opacity', 1);

		qline.setAttribute('x1', xq);
		qline.setAttribute('x2', xq);

		if (!disable_position_write) gids('query_l', lq);
		gids('query_q', qq, 5);
		gids('query_m', mq);
		gids('query_sl', slq, 6);
		gids('query_sh', shq);

		smid = shq / gidv('area');
		stop = - mq * gidv('rmax') / gidv('moi');
		sbot = + mq * gidv('rmin') / gidv('moi');

		gids("query_stress_bend_top", stop);
		gids("query_stress_bend_bot", sbot);
		gids("query_stress_shear",    smid);

		last_lq = lq;
	}

	function find_extrema_handler(event) {
		if (event.buttons != 2) return;
		query_l_unit = inputs_unit_map['query_l'][unit_sys];

		bg = document.getElementById('chart');
		xq = event.clientX - bg.getBoundingClientRect().left;
		//yq = event.clientY - bg.getBoundingClientRect().top;

		lq = (convert(focus_l_max, query_l_unit)-0)/(focus_xf-focus_x0)*(xq-focus_x0);
		if (lq > Math.max(...focus_l) || lq < 0)
			return;
		
		// init extremization algorithm
		idx = linterp_idx(focus_l, lq);
		direction = -sign(focus_m[idx]) * sign(focus_sl[idx]);
		if (direction == 0) direction = 1; // can't be indecisive
		max_or_min = -sign(focus_m[idx]);
		if (max_or_min == 0) max_or_min = 1;

		while ( idx >= 1 && idx < focus_l.length-1 ) {
			idx += direction;
			if (sign(focus_sl[idx+direction]) != max_or_min*direction)
				break;
		}

		focus_handler(focus_l[idx]);

		event.preventDefault();
		return false;
	}

	function drawchart(channels) {
		//var focus_l, focus_q, focus_m, focus_sl, focus_sh, focus_xf, focus_x0;
		drawbeam();
		beam_items = document.getElementById('beam_items');
		

		[l, q, sl, m, sh] = channels; //[xp, qp, tp, mp, sp];
		lc = convert_to(l, inputs_unit_map['query_l'][unit_sys]);
		qc = convert_to(q, inputs_unit_map['query_q'][unit_sys]);
		mc = convert_to(m, inputs_unit_map['query_m'][unit_sys]);
		slc = convert_to(q, inputs_unit_map['query_sl'][unit_sys]);
		shc = convert_to(m, inputs_unit_map['query_sh'][unit_sys]);

		svg    = document.getElementById('chart');
		x_axis = document.getElementById('chart_x_axis');
		y_axis = document.getElementById('chart_y_axis');

		x0 = Math.min(y_axis.x1.baseVal.value, y_axis.x2.baseVal.value);
		xf = Math.max(y_axis.x1.baseVal.value, y_axis.x2.baseVal.value);
		y0 = Math.max(x_axis.y1.baseVal.value, x_axis.y2.baseVal.value);
		yf = Math.min(x_axis.y1.baseVal.value, x_axis.y2.baseVal.value);

		q_line = document.getElementById('chart_q_line');
		m_line = document.getElementById('chart_m_line');
		q_line.setAttribute("points",""); // I don't like it, but it does clear the points
		m_line.setAttribute('points','');

		[[l_ticks], xticklabels] = makeTicks(null, [Math.max(...lc)], 1, 10);
		[[q_ticks], yticklabels] = makeTicks([Math.min(...qc), Math.min(...mc)], [Math.max(...qc), Math.max(...mc)], 1, 6);
		[[m_ticks], zticklabels] = makeTicks([Math.min(...mc), Math.min(...qc)], [Math.max(...mc), Math.max(...qc)], 1, 6);

		l_ticks.pop(); xticklabels.pop();
		
		l_max = Math.max(...lc);
		q_max = q_ticks[q_ticks.length-1];
		q_min = q_ticks[0];
		m_max = m_ticks[m_ticks.length-1];
		m_min = m_ticks[0];

		drawTicks('x', l_ticks, l_max, xticklabels, xf, x0, yf, y0, 15);
		drawTicks('y', null, null, yticklabels, yf, y0, xf, x0, 5);
		drawTicks('z', null, null, zticklabels, yf, y0, xf, x0, 5);

		for (i in lc) {
			var ptq = svg.createSVGPoint();
			var ptm = svg.createSVGPoint();

			xq = x0 + (xf-x0)/(l_max-0)*lc[i];
			ptq.x = ptm.x = xq;


			ptq.y   = y0 + (yf-y0)/(q_max-q_min)*(qc[i]-q_min);
			ptm.y   = y0 + (yf-y0)/(m_max-m_min)*(mc[i]-m_min);
			q_line.points.appendItem(ptq);
			m_line.points.appendItem(ptm);
		}
		
		bg_old=document.getElementById('chart_query_area');
		var bg = bg_old.cloneNode(true);
		bg_old.parentNode.replaceChild(bg, bg_old);

		qline = document.getElementById('chart_query_line');
		//qline.setAttribute('opacity', 0);

		gids('query_l', '-');
		gids('query_q', '-');
		gids('query_m', '-');
		gids('query_sl', '-');
		gids('query_sh', '-');

		gids("query_stress_bend_top", '-');
		gids("query_stress_bend_bot", '-');
		gids("query_stress_shear",    '-');

		focus_l_max = l_max;
		focus_l = l
		focus_q = q;
		focus_m = m;
		focus_sl = sl;
		focus_sh = sh;
		focus_xf = xf;
		focus_x0 = x0;
		//[focus_l, focus_q, focus_m, focus_sl, focus_sh, focus_xf, x0] = [l, q, m, sl, sh, xf, x0];

		

		bg.addEventListener('mousemove', focus_handler);
		bg.addEventListener('mousedown', focus_handler);
		bg.addEventListener('mousedown', find_extrema_handler);
		bg.addEventListener('contextmenu', function(e){e.preventDefault(); return false; });

		if (last_lq) focus_handler(last_lq);
	}
</script>

<html>
<body onload="thload()">
	<div style="width: 275px; float: left;" class="container">
		<h3>Thad's Beam Calculator</h3>
		<center><a href="./">Back To Index</a> - <a href="./docs/beamcalc.pdf">Model Documentation</a></center>

		<div class="odd">
		<center>
			  <input type="radio" id="unit_english" name="unit" value="english" onclick="switch_units(); compute();">
			  <label for="english">English</label>
			  <input type="radio" id="unit_metric" name="unit" value="metric" onclick="switch_units(); compute();" checked>
			  <label for="metric">Metric</label>
		</center>
		</div>

		<div class="even">
			<table>
				<tr>
					<th class='rowlabel'>Length</th>
					<td><input id='length' /></td>
					<td class='unit' id='unit_length'></td>
				</tr>
			</table>
		</div>
		<div class="odd">
			<table id="table_material">
				
				<tr>
					<th class='rowlabel'>Material</th>
					<td colspan>
						<select id="material" onchange="select_material(); compute();">
							<option value="custom">Custom</option>
						</select>
					</td>
					<td>
						<button type="button" onclick="collapse('material'); shape_select(true)" id='toggle_detail_section'>&#9650;</button>
					</td>

				</tr>
				<tr>
					<th class='rowlabel'>Flexural Modulus</th>
					<td><input id='elastic_modulus' value=69 /></td>
					<td class='unit' id='unit_elastic_modulus'></td>
				</tr><tr>
					<th class='rowlabel'>Flexural Strength</th>
					<td><input id='Sf' value=30 /></td>
					<td class='unit' id='unit_Sf'></td>
				</tr><tr>
					<th class='rowlabel'>Density</th>
					<td><input id='density' value=0 /></td>
					<td class='unit' id='unit_density'></td>
				</tr><tr>
					<th class='rowlabel'>Mass</th>
					<td><input id='mass' readonly /></td>
					<td class='unit' id='unit_mass'></td>
				</tr>
			</table>
		</div>
		<div class="even">
			<table id="table_section">
				<tr>
					<th class='rowlabel'>Cross-Section</th>
					<td>
						<select id="section" onchange="shape_select(); compute();">
							<option value="rndbar" selected='selected'>Round Bar</option>
							<option value="boxbar">Rect. Bar</option>
							<option value="boxtube">Box Tube</option>
							<option value="channel">Channel</option>
							<option value="rndtube">Round Tube</option>
							<option value="angle">Angle</option>
							<option value="hex">Hexagon</option>
							<option value="custom">Custom</option>
						</select>
					</td>
					<td>
						<button type="button" onclick="collapse('section'); shape_select(true)" id='toggle_detail_section'>&#9650;</button>
					</td>
				</tr>
				<tr>
					<td colspan=3>
						<center><img id='section_img' src='include/section_boxtube.svg' /></center>
					</td>
				</tr>
				<tr>
					<th class='rowlabel'>MOI<span class="ttt">The area moment of inertia for the section</span></th>
					<td><input id='moi' readonly /></td>
					<td class='unit' id='unit_moi'></td>
				</tr><tr>
					<th class='rowlabel'>Area<span class="ttt">Cross-sectional area</span></th>
					<td><input id='area' readonly /></td>
					<td class='unit' id='unit_area'></td>
				</tr><tr>
					<th class='rowlabel'>Top Height<span class="ttt">Distance from neutral axis to top of section</span></th>
					<td><input id='rmax' readonly /></td>
					<td class='unit' id='unit_rmax'></td>
				</tr><tr>
					<th class='rowlabel'>Bottom Height<span class="ttt">Distance from neutral axis to bottom of section</span></th>
					<td><input id='rmin' readonly /></td>
					<td class='unit' id='unit_rmin'></td>
				</tr><tr id='section_1_row'>
					<th class='rowlabel' id='section_1_label'>D1</th>
					<td><input id='section_1' value=5 /></td>
					<td class='unit' id='unit_section_1'></td>
				</tr><tr id='section_2_row'>
					<th class='rowlabel' id='section_2_label'>D2</th>
					<td><input id='section_2' /></td>
					<td class='unit' id='unit_section_2'></td>
				</tr><tr id='section_3_row'>
					<th class='rowlabel' id='section_3_label'>D3</th>
					<td><input id='section_3' /></td>
					<td class='unit' id='unit_section_3'></td>
				</tr><tr id='section_4_row'>
					<th class='rowlabel' id='section_4_label'>D4</th>
					<td><input id='section_4' /></td>
					<td class='unit' id='unit_section_4'></td>
				</tr><tr id='section_flip_row'>
					<th class='rowlabel' id='section_flip_label'>Flip?</th>
					<td><input type="checkbox" id='section_flip' /></td>
				</tr>
			</table>
		</div>
		<div class="even" id='loads'><center class="load"><button id='add_load_btn' onclick='add_load()'>Add Load</button><button id='compute_btn' onclick='compute()'>Compute</button><table id="table_protips">
				<tr>
					<th class='rowlabel' colspan=2>Pro-Tips and Easter Eggs</th>
					<td>
						<button type="button" onclick="collapse('protips'); shape_select(true)" id='toggle_detail_protips'>&#9650;</button>
					</td>
				</tr>
				<tr>
					<td colspan=3>
							Click on the chart to query points. <br/><br/>
							Click on the beam elements to query the corresponding points.<br/><br/>
							Right click on the chart near a local extrema to latch on and find the local extrema.<br/><br/>
							Moments are positive-counterclockwise.<br/><br/>
							Bending/shear extrema are at points of interest (constraints/loads). <br/><br/>
							The flexural strength and mass properties are for your usage/reference only- they aren't used in calculations.
					</td>
				</tr>
			</table></center></div> <!-- MAKE SURE NO SPACES! NO DEAD CHLDREN! -->
	</div>


<div style="margin-left: 0px;" class="container" id="charts">

<style>
	.beam {
		stroke: #555;
		stroke-width: 8px;
	}
	.graph {
		height: 600px !important;
		width: 700px !important;
	}

	.beam-shape {
		stroke: none;
	}

	.beam-arrow {
		stroke-width: 3;
	}

	.load {
		border-top: 2px solid #333 !important;
	}
</style>

<svg version="1.2" class="graph" id='chart' aria-labelledby="title" role="img">
  <title id="title">Position/Velocity Data</title>



<rect class="background" id="chart_background" x=70 y=20 width=555 height=430 />
<g class="x-grid">
  <line id="chart_x_axis" class="axes" x1=70 x2=70 y1=20 y2=450 ></line>
</g>
<g class="y-grid">
  <line id="chart_y_axis" class="axes" x1=70 x2=625 y1=235 y2=235></line>
  <line id="chart_z_axis" class="axes" x1=625 x2=625 y1=20 y2=450></line>
</g>

<g class="beam">
  <line id="chart_beam" class="beam" x1=70 x2=625 y1=550 y2=550 ></line>
</g>
<g id="chart_beam_items"></g>

<g class="x-grid" id="chart_x_grid"></g>
<g class="y-grid" id="chart_y_grid"></g>
<g class="z-grid" id="chart_z_grid"></g>

<g class="labels x-labels" id='chart_x_labels'>
  <text x="325" y=485 class="label-title" id="chart_x_label">Position [mm]</text>
</g>

<g class="labels y-labels" id='chart_y_labels'>
  <text x=-240 y=15 class="label-title" transform="rotate(270)" id="chart_q_label" fill="#0074d9">Deflection [mm]</text>
</g>

<g class="labels z-labels" id='chart_z_labels'>
  <text x=-240 y=700 class="label-title" transform="rotate(270)" id="chart_m_label" fill="#d91200">Bending Moment [N-m]</text>
</g>

<g class="labels x-labels" id='chart_x_axis_labels'></g>
<g class="labels z-labels" id='chart_z_axis_labels'></g>
<g class="labels y-labels" id='chart_y_axis_labels'></g>

<g class="query-line">
	<line id="chart_query_line" x1=100 x2=100 y1=15 y2=555></line>
</g>
<polyline
	id='chart_q_line'
	fill='none'
	stroke='#0074d9'
	stroke-width=2
	points="
	"/>
<polyline
	id='chart_m_line'
	fill='none'
	stroke='#d91200'
	stroke-width=2
	points="
	"/>

<rect id="chart_query_area" x=0 y=0 width=700 height=460 opacity=0 fill="#fff">
</svg>

<div class="output-graph">

		<table>
			<tr>
				<th class="rowlabel">Queried Position<span class="ttt">Query a position on the graph by clicking (and optionally dragging) a point.</span></th>
				<td><input id="query_l" onkeyup="focus_handler(gidv('query_l'), true);" /></td>
				<td class="unit" id="unit_query_l"></td>
			</tr><tr>
				<th class="rowlabel">Deflection</th>
				<td><input id="query_q" readonly /></td>
				<td class="unit" id="unit_query_q"></td>
			</tr><tr>
				<th class="rowlabel">Slope</th>
				<td><input id="query_sl" readonly /></td>
				<td class="unit" id="unit_query_sl"></td>
			</tr><tr>
				<th class="rowlabel">Bending Moment</th>
				<td><input id="query_m" readonly /></td>
				<td class="unit" id="unit_query_m"></td>
			</tr><tr>
				<th class="rowlabel">Shear Force<span class="ttt">Note: Shear force at a load/constraint is not properly defined. Query before and after.</span></th>
				<td><input id="query_sh" readonly /></td>
				<td class="unit" id="unit_query_sh"></td>
			</tr><tr>
				<th class="rowlabel">Bending Stress @ Top<span class="ttt">Positive is tension</span></th>
				<td><input id="query_stress_bend_top" readonly /></td>
				<td class="unit" id="unit_query_stress_bend_top"></td>
			</tr><tr>
				<th class="rowlabel">Bending Stress @ Bottom<span class="ttt">Positive is tension</span></th>
				<td><input id="query_stress_bend_bot" readonly /></td>
				<td class="unit" id="unit_query_stress_bend_bot"></td>
			</tr><tr>
				<th class="rowlabel">Shear Stress @ Center</th>
				<td><input id="query_stress_shear" readonly /></td>
				<td class="unit" id="unit_query_stress_shear"></td>
			</tr>
		</div>

</div>
</body>
</html>