<!DOCTYPE html>

<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<link rel="stylesheet" href="include/style.css"> 
<script type="text/javascript" src="js/motors.js"></script>
<script type="text/javascript" src="js/orings.js"></script>
<script type="text/javascript" src="js/belts.js"></script>
<script type="text/javascript" src="js/units.js"></script>
<script type="text/javascript" src="js/materials.js"></script>

<script type="text/javascript">
	EXP_FN_BASE = 'fit_tol';
	UNIT_MAP = {
		'dimension': ['mm', 'in'] // ezpz
	};
</script>

<script type="text/javascript">
	/*function permuationWithVariableRepeat(quantities) {
		const permutations = [];
		
		for (const id_a in quantities) {
			new_quantities = {}
			for (const id_b in quantities) {
				n = id_a == id_b ? quantities[id_b]-1 : quantities[id_b];
				if (n > 0)
					new_quantities[id_b] = n
			}

			if (Object.keys(new_quantities).length === 0) {
				permutations.push([id_a])
			} else {
				//console.log(tmpresults)
				for (const i of permuationWithVariableRepeat(new_quantities))
					permutations.push([id_a].concat(i))
			}
		}
		return permutations
	}*/

	// a part (or piece in general) is an object with operties: id, qty, length, profile

	function generateCutOrders(quantities, part_manifest, recieved_order, kerf_width) {
		const orders = [];
		
		for (const id_a in quantities) {
			new_quantities = {}
			for (const id_b in quantities) {
				n = id_a == id_b ? quantities[id_b]-1 : quantities[id_b];
				if (n > 0)
					new_quantities[id_b] = n
			}
			need_to_place_part = true;

			send_order = []
			for (line of recieved_order) {
				piece_lg = part_manifest[id_a].length
				if (need_to_place_part && line.remainder >= piece_lg+kerf_width) {
					send_order.push({
						stock_length: line.stock_length,
						pieces: line.pieces.concat(piece_lg),
						saw_waste: line.saw_waste + kerf_width,
						remainder: line.remainder - piece_lg - kerf_width
					})
					need_to_place_part = false;
				} else {
					// can I just push line? idk.
					send_order.push({
						stock_length: line.stock_length,
						pieces: line.pieces,
						saw_waste: line.saw_waste,
						remainder: line.remainder
					})
				}
			}

			if (need_to_place_part) {
				// hm. well, we couldn't place this part. fail!
				continue;
			}

			// spawn the next things
			if (Object.keys(new_quantities).length === 0) {
				// this is the last item in the line
				orders.push(send_order)
			} else {
				//console.log(tmpresults)
				let unique_set = new Set()
				for (const spawned_order of generateCutOrders(new_quantities, part_manifest, send_order, kerf_width)){
					// collect the order
					// !!!!!!!!! AT THIS POINT, KILL NON-UNIQUE ANSWERS !!!!!!!!!
					// generate a summary of what this particular piece is. This will be less data than taking the entire order
					// note this isn't perfect as it only works downstream.
					// wait but _shouldn't it still work_??????
					// it helps a lot but it doesn't seem to be perfect
					const summary = JSON.stringify(spawned_order.map((a) => JSON.stringify(a.pieces.sort((a,b)=>b-a).concat(a.stock_length))).sort())
					if (! unique_set.has(summary)) {
						unique_set.add(summary)
						// only add orders with a unique summary
						orders.push(spawned_order)
					}
				}
			}
		}
		return orders
	}

	/*function generateCutOrders(path, unstacked_cuts, parts_remaining, piece_manifest, stock_lg, kerf_width) {
		//console.log(path, parts_remaining)
		/* Key insight:
		 * From https://docs.python.org/2/library/itertools.html#itertools.combinations
		 * "After filtering entries where the elements are not in sorted order"
		 * 
		 * Provide cut orders that are sorted. Doesn't matter what that order is, as long as there's some order to it.
		 * Then, a higher level up than this function, eliminate duplicates.
		 *
		 * This is not a smart algorithm. It is very big.
		 *	
		// look at all new part options
		let stacked_cut_options = []
		for (const part of parts_remaining) {
			let stacked_cuts = [];

			// build what the new remaining parts BOM looks like after absorbing this part
			let new_parts = [];
			for (const part2 of parts_remaining) {
				const n = part2.name == part.name ? part2.qty-1 : part2.qty;
				if (n > 0)
					new_parts.push({
						name: part2.name,
						qty: n,
						profile: part2.profile,
						length: part2.length
					})
			}

			let unstacked_cuts2 = []

			if (unstacked_cuts.map(a => piece_manifest[a].length).reduce((a,b) => a+b+kerf_width, 0) + part.length > stock_lg) {
				// finished off a piece of stock
				if (part.length > stock_lg) {
					continue; // lol, no, can't be done!
				}
				stacked_cuts.push(unstacked_cuts);
			} else {
				for (const i of unstacked_cuts)
					unstacked_cuts2.push(i);
			}

			unstacked_cuts2.push(part.name)
			unstacked_cuts2.sort() // .sort() is in-place
			
			// TODO: we can only sort within the same pieces of stock, soooooooo... fix this.

			if (new_parts.length <= 0) {
				// final branch; whatever you've got at this point is all there is to it
				stacked_cut_options.push(stacked_cuts.concat([unstacked_cuts2]).sort())
			} else {
				// branch out
				try{ //path, unstacked_cuts, parts_remaining, piece_manifest, stock_lg, kerf_width
					const tmp = generateCutOrders(path+part.name, unstacked_cuts2, new_parts, piece_manifest, stock_lg, kerf_width);
					for (const i of tmp){
						stacked_cut_options.push(stacked_cuts.concat(i).sort())
					}
				} catch (e) {
					// out of stock presumably, which is OK
					console.log(e);
				}
			}
		}

		return stacked_cut_options;
	}*/

	function generateCutOptions(parts, stock, kerf_width) {
		console.log("generateCutOptions", parts, stock, kerf_width)

		parts.sort((a,b) => b.length - a.length)
		
		profiles = new Set();
		profiles_unaccounted = new Set();
		part_quantities = {}
		stock_lgs = {}
		orders_by_profile = {}

		piece_manifest = {}
		
		for (part of parts){
			piece_manifest[part.name] = {qty: part.qty, profile: part.profile, length: part.length}
			profiles.add(part.profile)
			profiles_unaccounted.add(part.profile)
			part_quantities[part.name] = part.qty
		}

		order_template = []
		
		let j = 0;
		for (part of stock){
			//piece_manifest[part.name] = {qty: part.qty, profile: part.profile, length: part.length}
			profiles_unaccounted.delete(part.profile);
			stock_lgs[part.profile] = part.length;
			for (let i=0; i<part.qty; i++)
				order_template.push({stock_length: part.length, pieces: [], saw_waste: 0, remainder: part.length, stock_id: j})
			j+=1;
		}

		if (profiles_unaccounted.size != 0) {
			console.log(profiles_unaccounted)
			throw "don't have stock defined for profiles: " + Array.from(profiles_unaccounted).join(', ');
		}

		console.log("generateCutOrders", part_quantities, piece_manifest, order_template, kerf_width)

		return generateCutOrders(part_quantities, piece_manifest, order_template, kerf_width)

		//return {manifest: piece_manifest, stock_length: stock_lgs, orders: orders_by_profile};
	}

	function representNumber(num) {
		if (num % 1 < .001)
			return num.toFixed(0);
		return num.toFixed(2);

	}

	function representOrder(order) {
		reprs = [];
		for (line of order) {
			repr = representNumber(line.stock_length) + " = ";
			for (piece of line.pieces) {
				repr += representNumber(piece) + " + ";
			}
			repr += "(--" + representNumber(line.saw_waste) + ") + (" + representNumber(line.remainder) + ")";
			reprs.push(repr);
		}
		return reprs.join('\n');
	}

	function init() {
		opts = generateCutOptions([{
			name: "A",
			qty: 6,
			profile: "pipe",
			length: 12
		},{
			name: "B",
			qty: 4,
			profile: "pipe",
			length: 30
		},{
			name: "C",
			qty: 4,
			profile: "pipe",
			length: 3
		}],[{
			name: "a",
			qty: 2,
			profile: "pipe",
			length: 43
		},{
			name: "b",
			qty: 4,
			profile: "pipe",
			length: 43
		}], .125)

		console.log(opts)

		for (order of opts) {
			order.sort((a,b) => a.remainder-b.remainder)
			order['remainder'] = 0;
			for (let i = order.length-1; i>=0; i--) {
				const line = order[i];
				if (line.remainder == line.stock_length){
					order.remainder += 1;
				}
				else{
					// only get the first one
					order.remainder += line.remainder/line.stock_length;
					break;
				}
			}
		}

		opts.sort((a,b) => b.remainder-a.remainder)

		for (order of opts) {
			console.log(representOrder(order))
		}
	}
</script>

<html>
<!-- Make sure to call your init function on document load -->
<!-- You can copy the topbar template here -->
<body onload="init()">
	<div id="topbar">
		<div class="topbar-la selectable" onclick="window.location='./'">EveryCalc</div>
		<div class="topbar-la" id='topbar_version'></div>
		<div class="topbar-la" id='topbar_filename'></div>
		<div class="topbar-la" id='topbar_unit'>
			<!-- Required for unit library. You could also put this in the calculator main body -->
			<select id="unit_select" onchange="UNIT_change(); compute();">
				<option value=0 >Millimeters</option>
				<option value=1 selected="selected">Inches</option>
			</select>
		</div>
		<div class="topbar-ctr" id="topbar_title">Fit Clearance/Interference Calculator</div>
		<div class="topbar-ra selectable" id="topbar_status"><span></span><span class='ttt'></span></div>
		<div class="topbar-ra selectable" onclick="downloadPage();" id="download">Export HTML</div>
		<div class="topbar-ra selectable" onclick="printPage();">Print</div>
		<div class="topbar-ra selectable" onclick="WALK_enable();">Tutorial</div>
		<a id="download_frame" hidden></a>
	</div>	

	<svg id="walkthrough_overlay" onclick="WALK_nextStep()" >
		<path id="walkthrough_frame" ></path>
		<text id="walkthrough_text" ></text>
		<text id="walkthrough_skip_button" onclick="WALK_disable();">Skip Tutorial</text>
	</svg>

<!-- From here go nuts, do whatever works for you. Use the container to keep stuff from spilling under topbar. I'll point out patterns to pay attention to. -->
	<div style="float: left;" class="container">
		<div style='display:table-row' id="fits" data-current_fit_number=0 ></div>
		<div><button id='addFit_btn' onclick='addFit()'>Add Fit</button></div>
	</div>
</body>
</html>