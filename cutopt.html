<!DOCTYPE html>

<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<link rel="stylesheet" href="include/style.css"> 
<script type="text/javascript" src="js/eclib.js"></script>
<script type="text/javascript" src="js/units.js"></script>
<script type="text/javascript" src="js/export.js"></script>
<script type="text/javascript" src="js/walkthrough.js"></script>

<script type="text/javascript">
	EXP_FN_BASE = 'fit_tol';
	UNIT_MAP = {
		'dimension': ['-', '-'] // ezpz
	};
</script>

<script type="text/javascript">
	/*function permuationWithVariableRepeat(quantities) {
		const permutations = [];
		
		for (const id_a in quantities) {
			new_quantities = {}
			for (const id_b in quantities) {
				n = id_a == id_b ? quantities[id_b]-1 : quantities[id_b];
				if (n > 0)
					new_quantities[id_b] = n
			}

			if (Object.keys(new_quantities).length === 0) {
				permutations.push([id_a])
			} else {
				//console.log(tmpresults)
				for (const i of permuationWithVariableRepeat(new_quantities))
					permutations.push([id_a].concat(i))
			}
		}
		return permutations
	}*/

	// a part (or piece in general) is an object with operties: id, qty, length, profile

	function generateCutOrders(quantities, part_manifest, recieved_order, kerf_width) {
		const orders = [];
		
		let unique_set = new Set()

		for (const id_a in quantities) {
			new_quantities = {}
			for (const id_b in quantities) {
				n = id_a == id_b ? quantities[id_b]-1 : quantities[id_b];
				if (n > 0)
					new_quantities[id_b] = n
			}
			need_to_place_part = true;

			send_order = []
			for (line of recieved_order) {
				piece_lg = part_manifest[id_a].length
				if (need_to_place_part && line.remainder >= piece_lg+kerf_width) {
					send_order.push({
						stock_length: line.stock_length,
						pieces: line.pieces.concat(piece_lg),
						saw_waste: line.saw_waste + kerf_width,
						remainder: line.remainder - piece_lg - kerf_width
					})
					need_to_place_part = false;
				} else {
					// can I just push line? idk.
					send_order.push(line)
				}
			}

			if (need_to_place_part) {
				// hm. well, we couldn't place this part. fail!
				continue;
			}

			// spawn the next things
			if (Object.keys(new_quantities).length === 0) {
				// this is the last item in the line
				orders.push(send_order)
			} else {
				//console.log(tmpresults)
				for (const spawned_order of generateCutOrders(new_quantities, part_manifest, send_order, kerf_width)){
					// collect the order
					// at this point, only accept unique cut orders.
					// this doesn't actually prevent us from going down rabbit holes that are useless, it's merely filtering
					// it at leasts prevents us from storing as much data as possible upfront
					const summary = JSON.stringify(spawned_order.map((a) => JSON.stringify(a.pieces.sort((a,b)=>b-a).concat(a.stock_length))).sort())
					if (! unique_set.has(summary)) {
						unique_set.add(summary)
						// only add orders with a unique summary
						orders.push(spawned_order)
					}
				}
			}
		}
		return orders
	}

	/*function generateCutOrders(path, unstacked_cuts, parts_remaining, piece_manifest, stock_lg, kerf_width) {
		//console.log(path, parts_remaining)
		/* Key insight:
		 * From https://docs.python.org/2/library/itertools.html#itertools.combinations
		 * "After filtering entries where the elements are not in sorted order"
		 * 
		 * Provide cut orders that are sorted. Doesn't matter what that order is, as long as there's some order to it.
		 * Then, a higher level up than this function, eliminate duplicates.
		 *
		 * This is not a smart algorithm. It is very big.
		 *	
		// look at all new part options
		let stacked_cut_options = []
		for (const part of parts_remaining) {
			let stacked_cuts = [];

			// build what the new remaining parts BOM looks like after absorbing this part
			let new_parts = [];
			for (const part2 of parts_remaining) {
				const n = part2.name == part.name ? part2.qty-1 : part2.qty;
				if (n > 0)
					new_parts.push({
						name: part2.name,
						qty: n,
						profile: part2.profile,
						length: part2.length
					})
			}

			let unstacked_cuts2 = []

			if (unstacked_cuts.map(a => piece_manifest[a].length).reduce((a,b) => a+b+kerf_width, 0) + part.length > stock_lg) {
				// finished off a piece of stock
				if (part.length > stock_lg) {
					continue; // lol, no, can't be done!
				}
				stacked_cuts.push(unstacked_cuts);
			} else {
				for (const i of unstacked_cuts)
					unstacked_cuts2.push(i);
			}

			unstacked_cuts2.push(part.name)
			unstacked_cuts2.sort() // .sort() is in-place
			
			// TODO: we can only sort within the same pieces of stock, soooooooo... fix this.

			if (new_parts.length <= 0) {
				// final branch; whatever you've got at this point is all there is to it
				stacked_cut_options.push(stacked_cuts.concat([unstacked_cuts2]).sort())
			} else {
				// branch out
				try{ //path, unstacked_cuts, parts_remaining, piece_manifest, stock_lg, kerf_width
					const tmp = generateCutOrders(path+part.name, unstacked_cuts2, new_parts, piece_manifest, stock_lg, kerf_width);
					for (const i of tmp){
						stacked_cut_options.push(stacked_cuts.concat(i).sort())
					}
				} catch (e) {
					// out of stock presumably, which is OK
					console.log(e);
				}
			}
		}

		return stacked_cut_options;
	}*/

	function generateCutOptions(parts, stock, kerf_width) {
		console.log("generateCutOptions", parts, stock, kerf_width)

		parts.sort((a,b) => b.length - a.length)
		
		profiles = new Set();
		profiles_unaccounted = new Set();
		part_quantities = {}
		stock_lgs = {}
		orders_by_profile = {}

		piece_manifest = {}
		
		for (part of parts){
			piece_manifest[part.name] = {qty: part.qty, profile: part.profile, length: part.length}
			profiles.add(part.profile)
			profiles_unaccounted.add(part.profile)
			part_quantities[part.name] = part.qty
		}

		order_template = []
		
		let j = 0;
		for (part of stock){
			//piece_manifest[part.name] = {qty: part.qty, profile: part.profile, length: part.length}
			profiles_unaccounted.delete(part.profile);
			stock_lgs[part.profile] = part.length;
			for (let i=0; i<part.qty; i++)
				order_template.push({stock_length: part.length, pieces: [], saw_waste: 0, remainder: part.length, stock_id: j})
			j+=1;
		}

		if (profiles_unaccounted.size != 0) {
			console.log(profiles_unaccounted)
			throw "don't have stock defined for profiles: " + Array.from(profiles_unaccounted).join(', ');
		}

		console.log("generateCutOrders", part_quantities, piece_manifest, order_template, kerf_width)

		return generateCutOrders(part_quantities, piece_manifest, order_template, kerf_width)

		//return {manifest: piece_manifest, stock_length: stock_lgs, orders: orders_by_profile};
	}

	function representNumber(num) {
		if (num % 1 < .001)
			return num.toFixed(0);
		return num.toFixed(2);

	}

	function representOrder(order) {
		reprs = [];
		for (line of order) {
			repr = representNumber(line.stock_length) + " = ";
			for (piece of line.pieces) {
				repr += representNumber(piece) + " + ";
			}
			repr += "(--" + representNumber(line.saw_waste) + ") + (" + representNumber(line.remainder) + ")";
			reprs.push(repr);
		}
		return reprs.join('\n');
	}

	var current_cut_options = [];

	function compute() {
		// hook for when computation is requested
		let new_tbody = document.createElement("tbody");
		let old_tbody = document.getElementById("tbody_cut_output");
		old_tbody.parentNode.replaceChild(new_tbody, old_tbody);
		new_tbody.id = 'tbody_cut_output';


		tbody_piece_input = document.getElementById("tbody_piece_input");
		tbody_stock_input = document.getElementById("tbody_stock_input");

		pieces = []
		stock  = []

		for (row of tbody_piece_input.children) {
			pieces.push({
				name:    row.cells[0].children[0].value,
				profile: row.cells[1].children[0].value,
				length:  parseFloat(row.cells[2].children[0].value),
				qty:     parseFloat(row.cells[3].children[0].value)
			});
		}

		for (row of tbody_stock_input.children) {
			stock.push({
				name:    row.cells[0].children[0].value,
				profile: row.cells[1].children[0].value,
				length:  parseFloat(row.cells[2].children[0].value),
				qty:     parseFloat(row.cells[3].children[0].value)
			});
		}

		current_cut_options = generateCutOptions(pieces, stock, .125)

		console.log(current_cut_options)

		// sort the options
		// todo: this should probably get rolled together, too many nested functions
		for (order of current_cut_options) {
			order.sort((a,b) => a.remainder-b.remainder)
			order['remainder'] = 0;
			for (let i = order.length-1; i>=0; i--) {
				const line = order[i];
				if (line.remainder == line.stock_length){
					order.remainder += 1;
				}
				else{
					// only get the first one
					order.remainder += line.remainder/line.stock_length;
					break;
				}
			}
		}

		current_cut_options.sort((a,b) => b.remainder-a.remainder)

		//for (order of current_cut_options)
		//	console.log(representOrder(order))


		let select    = document.getElementById("cut_option_select");
		let old_val   = select.value;
		select.innerHTML = '';
		for (base in current_cut_options) {
			let opt = document.createElement('option');
			opt.innerHTML = base;
			opt.value = base;
			if (old_val == base) opt.selected = true;
			select.appendChild(opt);
		}

		changeCutOption();

		setError(0);	
	}

	function changeCutOption() {
		let new_tbody = document.createElement("tbody");
		let old_tbody = document.getElementById("tbody_cut_output");
		old_tbody.parentNode.replaceChild(new_tbody, old_tbody);
		new_tbody.id = 'tbody_cut_output';

		let option_no = document.getElementById("cut_option_select").value;
		let cut_option = current_cut_options[option_no];

		console.log(cut_option)
		console.log(representOrder(cut_option))
		for (cut of cut_option) {
			let row = document.createElement("tr");

			overall   = cut.stock_length;
			cuts      = cut.pieces.join(' + ');
			kerfloss  = cut.saw_waste;
			remainder = cut.remainder;

			row.innerHTML = `
				<td class='td-readout'>${overall}</td>
				<td>=</td>
				<td class='td-readout' style='width: 250px'>${cuts}</td>
				<td>--</td>
				<td class='td-readout'>${kerfloss}</td>
				<td>--</td>
				<td class='td-readout'>${remainder}</td>
			`;

			new_tbody.appendChild(row);
		}
	}

	function init() {
		// hook for initialization
		EC_onload();

		//EXP_onload();

		for (inp of document.getElementsByTagName('TD')) {
			if (inp.contentEditable == 'true') {
				inp.addEventListener('keydown', (evt) => {
				    if (evt.keyCode === 13) {
				        evt.preventDefault();
				        // TODO: enter; go down
				    }
				    // TODO: other arrow keys
				});
			}
		}

		document.getElementById('idContentEditable')
		UNIT_change();
		//
		compute();
	}
</script>

<html>
<!-- Make sure to call your init function on document load -->
<!-- You can copy the topbar template here -->
<body onload="init()">
	<div id="topbar">
		<div class="topbar-la selectable" onclick="window.location='./'">EveryCalc</div>
		<div class="topbar-la" id='topbar_version'></div>
		<div class="topbar-la" id='topbar_filename'></div>
		<div class="topbar-la" id='topbar_unit'>
			<!-- Required for unit library. You could also put this in the calculator main body -->
			<select id="unit_select" onchange="UNIT_change(); compute();">
				<option value=0 selected="selected">Decimal</option>
				<option value=1 >Fractional</option>
			</select>
		</div>
		<div class="topbar-ctr" id="topbar_title" onclick="compute();">Fit Clearance/Interference Calculator</div>
		<div class="topbar-ra selectable" onclick="compute();" id="topbar_status"><span></span><span class='ttt'></span></div>
		<div class="topbar-ra selectable" onclick="downloadPage();" id="download">Export HTML</div>
		<div class="topbar-ra selectable" onclick="printPage();">Print</div>
		<div class="topbar-ra selectable" onclick="WALK_enable();">Tutorial</div>
		<a id="download_frame" hidden></a>
	</div>	

	<svg id="walkthrough_overlay" onclick="WALK_nextStep()" >
		<path id="walkthrough_frame" ></path>
		<text id="walkthrough_text" ></text>
		<text id="walkthrough_skip_button" onclick="WALK_disable();">Skip Tutorial</text>
	</svg>

<!-- From here go nuts, do whatever works for you. Use the container to keep stuff from spilling under topbar. I'll point out patterns to pay attention to. -->
	<div style="float: left;" class="container odd">
		<table id="table_piece_input">
			<tr>
				<th class="rowlabel bold" colspan="4" style="text-align: center;">Pieces</th>
			</tr>
			<tr>
				<td>Name</td>
				<td>Profile</td>
				<td>Length<!--<span class="unit" data-unit="dimension"></span>--></td>
				<td>Quantity</td>
			</tr>
			<tbody id="tbody_piece_input">
			<tr id='piece_1_row'>
				<td contenteditable="true" class="table-cell-input" id="piece_name_1"></td>
				<td contenteditable="true" class="table-cell-input" id="piece_profile_1"></td>
				<td contenteditable="true" class="table-cell-input" id="piece_length_1"></td>
				<td contenteditable="true" class="table-cell-input" id="piece_qty_1"></td>
			</tr>
			<tr id='piece_2_row'>
				<td contenteditable="true" class="table-cell-input" id="piece_name_2"></td>
				<td contenteditable="true" class="table-cell-input" id="piece_profile_2"></td>
				<td contenteditable="true" class="table-cell-input" id="piece_length_2"></td>
				<td contenteditable="true" class="table-cell-input" id="piece_qty_2"></td>
			</tr>
			<tr id='piece_3_row'>
				<td contenteditable="true" class="table-cell-input" id="piece_name_3"></td>
				<td contenteditable="true" class="table-cell-input" id="piece_profile_3"></td>
				<td contenteditable="true" class="table-cell-input" id="piece_length_3"></td>
				<td contenteditable="true" class="table-cell-input" id="piece_qty_3"></td>
			</tr>
		</tbody>
		</table>
	</div>
	
	<div style="float: left;" class="container even">
		<table id="table_stock_input">
			<tr>
				<th class="rowlabel bold" colspan="4" style="text-align: center;">Stock</th>
			</tr>
			<tr>
				<td>Name</td>
				<td>Profile</td>
				<td>Length<!--<span class="unit" data-unit="dimension"></span>--></td>
				<td>Quantity</td>
			</tr>
			<tbody id="tbody_stock_input">
			<tr id='stock_1_row'>
				<td contenteditable="true" class="table-cell-input" id="stock_name_1"></td>
				<td contenteditable="true" class="table-cell-input" id="stock_profile_1"></td>
				<td contenteditable="true" class="table-cell-input" id="stock_length_1"></td>
				<td contenteditable="true" class="table-cell-input" id="stock_qty_1"></td>
			</tr>
			<tr id='stock_2_row'>
				<td contenteditable="true" class="table-cell-input" id="stock_name_2"></td>
				<td contenteditable="true" class="table-cell-input" id="stock_profile_2"></td>
				<td contenteditable="true" class="table-cell-input" id="stock_length_2"></td>
				<td contenteditable="true" class="table-cell-input" id="stock_qty_2"></td>
			</tr>
			<tr id='stock_3_row'>
				<td contenteditable="true" class="table-cell-input" id="stock_name_3"></td>
				<td contenteditable="true" class="table-cell-input" id="stock_profile_3"></td>
				<td contenteditable="true" class="table-cell-input" id="stock_length_3"></td>
				<td contenteditable="true" class="table-cell-input" id="stock_qty_3"></td>
			</tr>
		</tbody>
		</table>
	</div>
	
	<div style="float: left;" class="container output">
		<table id="table_cut_output">
			<tr>
				<th class="rowlabel bold" colspan="7" style="text-align: left;">Cut Option 
					<select id="cut_option_select" onchange="changeCutOption();">
					</select>
				</th>
			</tr>
			<tr>
				<td colspan>Stock Lg.</td>
				<td>=</td>
				<td colspan>Cuts</td>
				<td>--</td>
				<td colspan>Kerf Loss</td>
				<td>--</td>
				<td colspan>Spare</td>
			</tr>
			<tbody id="tbody_cut_output">
				<tr id='cut_1_row' class="cut_row">
					<td id="cut_overall_1"></td>
					<td>=</td>
					<td id="cut_pieces_1"></td>
					<td>--</td>
					<td id="cut_kerfloss_1"></td>
					<td>--</td>
					<td id="cut_remainder_1"></td>
				</tr>
			</tbody>
		</table>		
	</div>
</body>
</html>