<!DOCTYPE html>

<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<link rel="stylesheet" href="include/style.css"> 
<script type="text/javascript" src="js/motors.js"></script>
<script type="text/javascript" src="js/orings.js"></script>
<script type="text/javascript" src="js/belts.js"></script>
<script type="text/javascript" src="js/units.js"></script>
<script type="text/javascript" src="js/materials.js"></script>

<script type="text/javascript">
	EXP_FN_BASE = 'fit_tol';
	UNIT_MAP = {
		'dimension': ['mm', 'in'] // ezpz
	};
</script>

<script type="text/javascript">
	/*function permuationWithVariableRepeat(remaining) {
		const results = []
		
		for (const part in remaining) {
			new_parts = {}
			for (const part2 in remaining) {
				n = part2 == part ? remaining[part2]-1 : remaining[part2];
				if (n > 0)
					new_parts[part2] = n
			}

			if (Object.keys(new_parts).length === 0) {
				results.push([part])
			} else {
				const tmpresults = permuationWithVariableRepeat(new_parts)
				//console.log(tmpresults)
				for (const i in tmpresults)
					results.push([part].concat(tmpresults[i]))
			}
		}
		return results
	}*/

	// a part (or piece in general) is an object with operties: id, qty, length, profile

	function cutStock(parts, stock_lg) {

	}

	function generateCutOrders(path, unstacked_cuts, parts_remaining, piece_manifest, stock_lg, kerf_width) {
		//console.log(path, parts_remaining)
		/* Key insight:
		 * From https://docs.python.org/2/library/itertools.html#itertools.combinations
		 * "After filtering entries where the elements are not in sorted order"
		 * 
		 * Provide cut orders that are sorted. Doesn't matter what that order is, as long as there's some order to it.
		 * Then, a higher level up than this function, eliminate duplicates.
		 *
		 * This is not a smart algorithm. It is very big.
		 */	
		// look at all new part options
		let stacked_cut_options = []
		for (const part of parts_remaining) {
			let stacked_cuts = [];

			// build what the new remaining parts BOM looks like after absorbing this part
			let new_parts = [];
			for (const part2 of parts_remaining) {
				const n = part2.name == part.name ? part2.qty-1 : part2.qty;
				if (n > 0)
					new_parts.push({
						name: part2.name,
						qty: n,
						profile: part2.profile,
						length: part2.length
					})
			}

			let unstacked_cuts2 = []

			if (unstacked_cuts.map(a => piece_manifest[a].length).reduce((a,b) => a+b+kerf_width, 0) + part.length > stock_lg) {
				// finished off a piece of stock
				if (part.length > stock_lg) {
					continue; // lol, no, can't be done!
				}
				stacked_cuts.push(unstacked_cuts);
			} else {
				for (const i of unstacked_cuts)
					unstacked_cuts2.push(i);
			}

			unstacked_cuts2.push(part.name)
			unstacked_cuts2.sort() // .sort() is in-place
			
			// TODO: we can only sort within the same pieces of stock, soooooooo... fix this.

			if (new_parts.length <= 0) {
				// final branch; whatever you've got at this point is all there is to it
				stacked_cut_options.push(stacked_cuts.concat([unstacked_cuts2]).sort())
			} else {
				// branch out
				try{ //path, unstacked_cuts, parts_remaining, piece_manifest, stock_lg, kerf_width
					const tmp = generateCutOrders(path+part.name, unstacked_cuts2, new_parts, piece_manifest, stock_lg, kerf_width);
					for (const i of tmp){
						stacked_cut_options.push(stacked_cuts.concat(i).sort())
					}
				} catch (e) {
					// out of stock presumably, which is OK
					console.log(e);
				}
			}
		}

		return stacked_cut_options;
	}

	function generateCutOptions(parts, stock, kerf_width) {
		console.log("generateCutOptions", parts, stock, kerf_width)

		parts.sort((a,b) => b.length - a.length)
		
		profiles = new Set();
		profiles_unaccounted = new Set();
		stock_lgs = {}
		orders_by_profile = {}

		piece_manifest = {}
		
		for (part of parts){
			piece_manifest[part.name] = {qty: part.qty, profile: part.profile, length: part.length}
			profiles.add(part.profile)
			profiles_unaccounted.add(part.profile)
		}
		
		for (part of stock){
			//piece_manifest[part.name] = {qty: part.qty, profile: part.profile, length: part.length}
			profiles_unaccounted.delete(part.profile);
			stock_lgs[part.profile] = part.length;
		}

		if (profiles_unaccounted.size != 0) {
			console.log(profiles_unaccounted)
			throw "don't have stock defined for profiles: " + Array.from(profiles_unaccounted).join(', ');
		}

		for (profile of profiles) {
			orders = Array.from(
					new Set(
						generateCutOrders("", [], parts, piece_manifest, stock_lgs[profile], kerf_width)
						.map(a => JSON.stringify(a))
				)).map(a => JSON.parse(a))

			orders.sort(function(a, b){
				//if (a.length != b.length)
				return a.length - b.length;
			})
			orders_by_profile[profile] = orders;
		}

		return {manifest: piece_manifest, stock_length: stock_lgs, orders: orders_by_profile};
	}

	function representNumber(num) {
		if (num % 1 < .001)
			return num.toFixed(0);
		return num.toFixed(2);

	}

	function representOrder(piece_manifest, stock_lg, kerf_width, order) {
		reprs = [];
		for (stock of order) {
			repr = stock_lg.toFixed(2) + " = ";
			for (piece of stock) {
				repr += representNumber(piece_manifest[piece].length) + " + ";
			}
			repr += "(--" + representNumber(kerf_width*stock.length) + ") + (" + representNumber(stock_lg-kerf_width*stock.length-stock.reduce((a,b) => a+piece_manifest[b].length, 0)) + ")";
			reprs.push(repr);
		}
		return reprs;
	}

	function init() {
		opts = generateCutOptions([{
			name: "A",
			qty: 3,
			profile: "pipe",
			length: 12
		},{
			name: "B",
			qty: 3,
			profile: "pipe",
			length: 30
		},{
			name: "C",
			qty: 4,
			profile: "pipe",
			length: 3
		}],[{
			name: "a",
			qty: 2,
			profile: "pipe",
			length: 43
		}], .125)

		console.log(opts)

		for (profile in opts.orders) { 
			for (order of opts.orders[profile]) {
				console.log(representOrder(opts.manifest, opts.stock_length[profile], .125, order))
			}
		}
	}
</script>

<html>
<!-- Make sure to call your init function on document load -->
<!-- You can copy the topbar template here -->
<body onload="init()">
	<div id="topbar">
		<div class="topbar-la selectable" onclick="window.location='./'">EveryCalc</div>
		<div class="topbar-la" id='topbar_version'></div>
		<div class="topbar-la" id='topbar_filename'></div>
		<div class="topbar-la" id='topbar_unit'>
			<!-- Required for unit library. You could also put this in the calculator main body -->
			<select id="unit_select" onchange="UNIT_change(); compute();">
				<option value=0 >Millimeters</option>
				<option value=1 selected="selected">Inches</option>
			</select>
		</div>
		<div class="topbar-ctr" id="topbar_title">Fit Clearance/Interference Calculator</div>
		<div class="topbar-ra selectable" id="topbar_status"><span></span><span class='ttt'></span></div>
		<div class="topbar-ra selectable" onclick="downloadPage();" id="download">Export HTML</div>
		<div class="topbar-ra selectable" onclick="printPage();">Print</div>
		<div class="topbar-ra selectable" onclick="WALK_enable();">Tutorial</div>
		<a id="download_frame" hidden></a>
	</div>	

	<svg id="walkthrough_overlay" onclick="WALK_nextStep()" >
		<path id="walkthrough_frame" ></path>
		<text id="walkthrough_text" ></text>
		<text id="walkthrough_skip_button" onclick="WALK_disable();">Skip Tutorial</text>
	</svg>

<!-- From here go nuts, do whatever works for you. Use the container to keep stuff from spilling under topbar. I'll point out patterns to pay attention to. -->
	<div style="float: left;" class="container">
		<div style='display:table-row' id="fits" data-current_fit_number=0 ></div>
		<div><button id='addFit_btn' onclick='addFit()'>Add Fit</button></div>
	</div>
</body>
</html>