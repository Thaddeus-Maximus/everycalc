<!DOCTYPE html>
<link rel="stylesheet" href="include/style.css"> 
<script type="text/javascript" src="include/specs.js"></script>
<script type="text/javascript">

	unit_sys = 1;
	inputs_unit_map = {
		'theta': 			['deg', 'deg', 'deg'],
		'theta_err': 		['deg', 'deg', 'deg'],
		'v_initial':     	['m/s', 'ft/s','in/s'],
		'v_initial_err': 	['m/s', 'ft/s','in/s'],
		'x_target':      	['m',   'ft',  'in'],
		'x_target_err':  	['m',   'ft',  'in'],
		'y_target':      	['m',   'ft',  'in'],
		'y_target_err':  	['m',   'ft',  'in'],
		'y_initial':     	['m',   'ft',  'in'],
		'y_initial_err': 	['m',   'ft',  'in'],
		'x_obstacle':     	['m',   'ft',  'in'],
		'x_obstacle_err': 	['m',   'ft',  'in'],
		'h_obstacle':     	['m',   'ft',  'in'],
		'h_obstacle_err': 	['m',   'ft',  'in'],
		'h_target':      	['mm',  'in',  'in'],
		'h_target_err':  	['mm',  'in',  'in'],
		'd_ball':        	['mm',  'in',  'in'],
		'd_ball_err':    	['mm',  'in',  'in'],
		'strike_height':    ['m',   'ft',  'in'],
		'strike_height_err':['m',   'ft',  'in'],
		'sweep_height':     ['m',   'ft',  'in'],
		'sweep_height_err': ['m',   'ft',  'in'],
		'strike_angle':     ['deg', 'deg', 'deg'],
		'strike_angle_err': ['deg', 'deg', 'deg'],
		'm_ball':     		 ['kg', 'lbm', 'lbm'],
		'm_ball_err': 		 ['kg', 'lbm', 'deg'],
		'omega_initial': 	 ['RPM', 'RPM', 'RPM'],
		'omega_initial_err': ['RPM', 'RPM', 'RPM']
	};

	function populate_units() {
		if(document.getElementById('unit_metric').checked)
			unit_sys = 0;
		else if (document.getElementById('unit_english').checked)
			unit_sys = 1;
		else
			unit_sys = 2;

		unit_labels = document.getElementsByClassName('unit');
		for (unit in unit_labels) {
			if (unit_labels[unit].id && inputs_unit_map[unit_labels[unit].id.substring(5)] ){
				varname = unit_labels[unit].id.substring(5);
				document.getElementById('unit_'+varname).innerHTML = '['+inputs_unit_map[varname][unit_sys]+']';
			}
		}



		document.getElementById(chart_name+'_x_label').innerHTML = 'Distance ['+inputs_unit_map['y_target'][unit_sys]+']';
		document.getElementById(chart_name+'_y_label').innerHTML = 'Height ['+inputs_unit_map['y_target'][unit_sys]+']';
	}

	function switch_units() {
		populate_units();
		compute();
	}

    function mode_select() {
    	var mode = document.getElementById('mode').value;
    	document.getElementById('x_target').readOnly = false;
    	if (mode=='raw') {
    		document.getElementById('v_initial').readOnly = false;
    		document.getElementById('theta').readOnly     = false;
    	} else if (mode=='find_theta') {
    		document.getElementById('v_initial').readOnly = false;
    		document.getElementById('theta').readOnly     = true;
    	} else if (mode=='find_v') {
    		document.getElementById('v_initial').readOnly = true;
    		document.getElementById('theta').readOnly     = false;
    	} else if (mode=='find_min_v') {
    		document.getElementById('v_initial').readOnly = true;
    		document.getElementById('theta').readOnly     = true;
    	} else if (mode.startsWith('find_distance')) {
    		document.getElementById('v_initial').readOnly = false;
    		document.getElementById('theta').readOnly     = false;
    		document.getElementById('x_target').readOnly  = true;
    	}
    }

	function gidv(id) {
		var v =  document.getElementById(id).value;
		if (typeof v === 'string' && v.slice(-1) == '%') {
			v = eval(document.getElementById(id.slice(0,-4)).value)*eval(v.slice(0,-1)/100);
		} else if (v=='') {
			v = 0;
		
		} else {
			v = eval(v);
		}
		
		if (typeof inputs_unit_map[id] !== 'undefined') {
			v = convert(v, inputs_unit_map[id][unit_sys]);
		}
		return v;
	}

	function gids(id, value, places) {
		if (typeof places === 'undefined')
			places = 3;
		if (typeof value === 'string') {
			document.getElementById(id).value = value;
		} else {
			if (typeof inputs_unit_map[id] !== 'undefined'){

				
				value = convert_to(value, inputs_unit_map[id][unit_sys]);
			}
			document.getElementById(id).value = value.toFixed(places);
		}
	}

	function thload() {
		document.getElementById('topbar_version').innerHTML = VERSION;
		if(packed_inputs) unpack_inputs();
		populate_units();
		mode_select();

		var inputs, index;

		inputs = document.getElementsByTagName('input');
		for (index = 0; index < inputs.length; ++index) {
		    inputs[index].onkeyup = function(e) {
		    	var key = e.keyCode ? e.keyCode : e.which;

		    	if (key==13) {
		    		compute(true);
		    	} else {
		    		compute(false);
		    	}
		    }
		}

		compute(true);
	}

	function collapse(id) {
		tbl = document.getElementById('table_'+id);

		btn = document.getElementById('toggle_detail_'+id);
		if(tbl.rows[1].style['display'] != 'none') {
			for(i=1;i<tbl.rows.length;i++) tbl.rows[i].style['display'] = 'none';
			btn.innerHTML = "&#9660";
		} else {
			for(i=1;i<tbl.rows.length;i++) tbl.rows[i].style['display'] = 'table-row';
			btn.innerHTML = "&#9650";
		}
	}
		
	function sign(x) {
		if (x>0) return 1;
		if (x<0) return -1;
		return 0;
	}

	en_vm = true;

	function linterp(xs, ys, xq) {
		i;
		for (i=1; i<xs.length-1 && !isNaN(xs[i]) && xq>xs[i]; i++) {}
		return ys[i-1] + (ys[i]-ys[i-1])/(xs[i]-xs[i-1])*(xq-xs[i-1]);
	}

	function linterpder(xs, ys, xq) {
		i;
		for (i=1; i<xs.length-1 && !isNaN(xs[i]) && xq>xs[i]; i++) {}
		return (ys[i]-ys[i-1])/(xs[i]-xs[i-1]);
	}

	function convert_to_array(xyn, to) {
		newxyn = [];
		for(i=0;i<xyn.length;i++) {
			l = [];
			if (typeof xyn[i] === 'object') {
				for(j=0;j<xyn[i].length;j++) {
					l.push(convert_to(xyn[i][j], to));
				}
				newxyn.push(l);
			} else {
				newxyn.push(convert_to(xyn[i], to));
			}
		}
		return newxyn;
	}

	function run_sim(params_pack) {
		[v, theta, y0, xtarg, d, m, omega, Cd, Cl, Cm] = params_pack;
		
		rho = 1.1839; // kg/m^3
		A   = d*d*Math.PI/4;

		mu_d = 1/2*rho*A*Cd;
		mu_l = 1/2*rho*A*Cl;
		mu_m = Math.PI/3*rho*d*d*d*Cm;

		x=-xtarg;
		y=y0;
		vx=Math.cos(theta)*v;
		vy=Math.sin(theta)*v;
		vbar = v;
		g=9.81;
		xl=x; xh=x;

		dt = xtarg/v/100;
		res_ctr = [[x],[y]];
		res_low = [[],[]];
		res_high = [[],[]];

		y_low=0;
		y_high=0;
		tof=0;

		i=0;
		t=0;
		while(i<3000 && xh<=xtarg*0.05 && xl<=xtarg*0.05 && y>=0) {
			// Normal-tangent components
			Tx =  vx/vbar;
			Ty =  vy/vbar;
			Nx = -vy/vbar;
			Ny =  vx/vbar;

			Fd = mu_d * vbar*vbar;
			Fl = mu_l * vbar*vbar;
			Fm = mu_m * vbar*omega;

			vy += (-g - Fd*Ty + Fl*Ny + Fm*Ny)*dt;
			vx += (   - Fd*Tx + Fl*Nx + Fm*Nx)*dt;
			x += vx*dt;
			y += vy*dt;
			t += dt;
			vbar = Math.sqrt(Math.pow(vx,2) + Math.pow(vy,2));

			

			xl = x + d/2 * vy/vbar;
			xh = x - d/2 * vy/vbar;
			yl = y - d/2 * vx/vbar;
			yh = y + d/2 * vx/vbar;

			if (x>0) {
				tof = t;
			}

			res_ctr[0] .push(x);
			res_ctr[1] .push(y);
			res_low[0] .push(xl);
			res_low[1] .push(yl);
			res_high[0].push(xh);
			res_high[1].push(yh);

			i+=1;
		}

		stats = {
			'y_low':  linterp(res_low[0],res_low[1], 0),
			'y_high': linterp(res_high[0],res_high[1], 0),
			'y_ctr':  linterp(res_ctr[0],res_ctr[1], 0),
			'ang':    Math.atan(linterpder(res_ctr[0],res_ctr[1], 0)),
			'tof':    tof
		}

		return [res_low, res_ctr, res_high, stats];
	}

	function bit_test(num, bit){
	    return ((num>>bit) % 2 != 0)
	}

	g = 9.81;

	function compute(simulate) {
		mode = document.getElementById('mode').value;
		var x,y,v,theta;
		if (mode=='raw') {
    		// nothing special
    		x = gidv('x_target');
    		y = gidv('y_target');
    		theta = gidv('theta');
    		v = gidv('v_initial');
    	} else if (mode=='find_theta') {
    		x = gidv('x_target');
    		y = gidv('y_target') - gidv('y_initial');
    		v = gidv('v_initial');

    		theta = Math.atan((Math.pow(v,2) - Math.sqrt(Math.pow(v,4)-g*(g*x*x+2*y*v*v)))/g/x);
    		
    		gids('theta', theta);
    	} else if (mode=='find_v') {
    		x = gidv('x_target');
    		y = gidv('y_target') - gidv('y_initial');
    		theta = gidv('theta');

    		v     = x/Math.cos(theta)*Math.sqrt(g/2/(x*Math.tan(theta)-y));

    		gids('v_initial', v);
    	} else if (mode=='find_min_v') {
    		x = gidv('x_target');
    		y = gidv('y_target') - gidv('y_initial');

    		theta = Math.atan(y/x + Math.sqrt(y*y/x/x+1));
    		v     = x/Math.cos(theta)*Math.sqrt(g/2/(x*Math.tan(theta)-y));

    		gids('theta', theta);
    		gids('v_initial', v);
    	} else if (mode=='find_distance_far') {
    		// There are two positions...
    		theta = gidv('theta');
    		v     = gidv('v_initial');
    		y     = gidv('y_target') - gidv('y_initial');

    		x = Math.cos(theta)/g*(v*v*Math.sin(theta) + v*Math.sqrt(v*v*Math.sin(theta)*Math.sin(theta) - 2*g*y));
    		gids('x_target', x);
    	} else if (mode=='find_distance_near') {
    		// There are two positions...
    		theta = gidv('theta');
    		v     = gidv('v_initial');
    		y     = gidv('y_target') - gidv('y_initial');

    		x = Math.cos(theta)/g*(v*v*Math.sin(theta) - v*Math.sqrt(v*v*Math.sin(theta)*Math.sin(theta) - 2*g*y));
    		gids('x_target', x);
    	}

    	computable_ids = ['charts', 'strike_height', 'strike_height_err', 'sweep_height', 'sweep_height_err', 'strike_angle', 'strike_angle_err', 'time_of_flight', 'time_of_flight_err']
    	for (id of computable_ids) {
	    	document.getElementById(id).classList.remove('error');    
	    	document.getElementById(id).classList.remove('uncomputed');    
	    	document.getElementById(id).classList.add(isNaN(v)||isNaN(x)||isNaN(y)||isNaN(theta) ? 'error':'uncomputed');
    	}


		simulate = typeof simulate !== 'undefined' ? simulate : true;
		if(!simulate) return; // lol you gotta simulate this

		max_low       = +Infinity;
		max_low_stat  = {};
		max_low_run   = [];
		max_high      = -Infinity;
		max_high_stat = {};
		max_high_run  = [];
		params_list   = ['v_initial', 'theta', 'y_initial', 'x_target', 'd_ball', 'm_ball', 'omega_initial', 'Cd', 'Cl', 'Cm'];
		params_var_list  = [];
		params_var_count = 0;
		for (param of params_list) {
			if (gidv(param+'_err')) {
				params_var_list.push(true);
				params_var_count++;
			} else {
				params_var_list.push(false);
			}
		}
		low_omega_w   = +Infinity;

		for (var i=0; i<Math.pow(2, params_var_count); i++) {
			params = [];
			pvc = 0;
			for (j=0; j<params_list.length; j++) {
				if (params_var_list[j]) {
					params.push(gidv(params_list[j]) + (bit_test(i,pvc) ? 1:-1)*gidv(params_list[j]+'_err'));
					pvc ++;
				} else {
					params.push(gidv(params_list[j]));
				}
			}
			run = run_sim(params);
			if (run[3]['y_low'] < max_low)   {
				max_low      = run[3]['y_low'];
				max_low_run  = run[0];
				max_low_stat = run[3];
			}
			if (run[3]['y_high'] > max_high) {
				max_high      = run[3]['y_high'];
				max_high_run  = run[2];
				max_high_stat = run[3];
			}
		}
		
		max_low_run  = convert_to_array(max_low_run,  inputs_unit_map['y_target'][unit_sys]);
		max_high_run = convert_to_array(max_high_run, inputs_unit_map['y_target'][unit_sys]);
		targetstuff  = convert_to_array([gidv('x_target'), gidv('y_target'), gidv('h_target'), gidv('x_obstacle'), gidv('h_obstacle')], inputs_unit_map['y_target'][unit_sys] ) ;
      	drawchart(max_low_run, max_high_run, targetstuff, 
      		(max_high_stat.y_high > gidv('y_target')+gidv('h_target')/2) || (max_low_stat.y_low < gidv('y_target')-gidv('h_target')/2));

		for (id of computable_ids){
			document.getElementById(id).classList.remove('error');    
	    	document.getElementById(id).classList.remove('uncomputed');    	
		}
      	gids('strike_height',     (max_high_stat['y_ctr'] +max_low_stat['y_ctr'])/2);
      	gids('strike_height_err', (max_high_stat['y_ctr'] -max_low_stat['y_ctr'])/2);
      	gids('sweep_height',      (max_high_stat['y_high']+max_low_stat['y_low'])/2);
      	gids('sweep_height_err',  (max_high_stat['y_high']-max_low_stat['y_low'])/2);
      	gids('strike_angle',      (max_high_stat['ang']   +max_low_stat['ang'])/2);
      	gids('strike_angle_err',  Math.abs(max_high_stat['ang']-max_low_stat['ang'])/2);
      	gids('time_of_flight',    (max_high_stat['tof']   +max_low_stat['tof'])/2);
      	gids('time_of_flight_err',Math.abs(max_high_stat['tof']-max_low_stat['tof'])/2);
	}

	function NaNtoerr(x) {
		if (isNaN(x)) return '-'; return x;
	}


	function NaNto1(x) {
		if (isNaN(x))
			return 1;
		return x;
	}
</script>

<script type="text/javascript">
	function makeTicks(start_at, go_to, num_to_print, n) {
		//if (Math.min(maxes) < 0) return [0];

		
		if(start_at < 0) { //  thats not very general purpose of u
			h = (-start_at)/n;
			base = Math.floor(Math.log10(h)-Math.log10(5));
			H = Math.round(h/Math.pow(10, base))*Math.pow(10, base);

			ticks = [];
			ticksstr = [];
			for(var i=-1; i<n+1; i++) {
				ticks.unshift(-H*i);
				labelstr = (-H*i).toFixed(base > 0 ? 0:-base);
				ticksstr.unshift(labelstr);
			}
		} else {
			h = (go_to)/n;
			base = Math.floor(Math.log10(h)-Math.log10(5));
			H = Math.round(h/Math.pow(10, base))*Math.pow(10, base);

			ticks = [];
			ticksstr = [];
			for(var i=0; i<n+1; i++) {
				ticks.push(H*i);
				labelstr = (H*i).toFixed(base > 0 ? 0:-base);
				ticksstr.push(labelstr);
			}
		}
		return [ticks, ticksstr];
	}

	function sign(x) {
		if(x>0) return 1;
		if(x<0) return -1;
		return 0;
	}

	chart_name = 'chart';

	function drawTicks(axis, ticklabels, ff, f0, gf, g0, marg) {
		altaxis = axis == 'x' ? 'y':'x';
		realaxis = axis == 'z' ? 'y':axis;
		xgrid = document.getElementById(chart_name+'_'+axis+'_grid');
		while(xgrid.firstChild) xgrid.removeChild(xgrid.firstChild);

		labels = document.getElementById(chart_name+'_'+axis+'_axis_labels');
		while(labels.firstChild) labels.removeChild(labels.firstChild);

		gfl = (axis=='z'?gf:g0) + (axis=='y'?-1:1)*marg;

		for (i in ticklabels) {
			line = document.createElementNS('http://www.w3.org/2000/svg','line');
			line.setAttribute(altaxis+'1', gf); line.setAttribute(altaxis+'2', g0);
			fp = f0 + (ff-f0)*(i/(ticklabels.length-1));
			line.setAttribute(realaxis+'1', fp);
			line.setAttribute(realaxis+'2', fp);
			line.setAttribute('class', 'grid');
			xgrid.append(line);

			label = document.createElementNS('http://www.w3.org/2000/svg','text');
			label.setAttribute(altaxis, gfl);
			label.setAttribute(realaxis, fp);
			label.innerHTML = ticklabels[i];
			labels.append(label);
		}
	}

	function clean_run(run) {
		for (var i=run[0].length-1; i>0; i--) {
			if (run[0][i] < 0) {
				yint = linterp(run[0], run[1], 0);
				arr = [run[0].slice(0,i-1).concat(0), run[1].slice(0,i-1).concat(yint)];

				return arr;
			}
		} 
		
	}


	function makept(scaling, xq, yq) {
		[x0, y0, xf, yf, xl, xm, ym] = scaling;
		var pt = svg.createSVGPoint();
		pt.x = x0 + (xf-x0)/(xm-xl)*(xq-xl);
		pt.y = y0 + (yf-y0)/(ym-0)*yq;
		return pt;
	}

	function drawchart(low_run, high_run, targetstuff, missed) {
		[target_d, target_h, target_diam, x_obstacle, h_obstacle] = targetstuff;
		low_run = clean_run(low_run);
		high_run = clean_run(high_run);

		var d = low_run[0].concat(high_run[0].reverse());
		var h = low_run[1].concat(high_run[1].reverse());

		svg = document.getElementById('chart');
		x_axis = document.getElementById('chart_x_axis');
		y_axis = document.getElementById('chart_y_axis');

		x0 = Math.min(x_axis.x1.baseVal.value, x_axis.x2.baseVal.value);
		xf = Math.max(x_axis.x1.baseVal.value, x_axis.x2.baseVal.value);
		y0 = Math.max(y_axis.y1.baseVal.value, y_axis.y2.baseVal.value);
		yf = Math.min(y_axis.y1.baseVal.value, y_axis.y2.baseVal.value);

		shot_area = document.getElementById('chart_shot_area');
		shot_area.setAttribute("points","");

		maxht = Math.max(Math.max(...h), target_h+target_diam);
		mindist = Math.min(...d);

		[d_ticks, d_ticklabels] = makeTicks(mindist, 0, 1, 6);
		[h_ticks, h_ticklabels] = makeTicks(0,    maxht, 1, 6);


		d_max = d_ticks[d_ticks.length-1];
		d_min = d_ticks[0];
		h_max = h_ticks[h_ticks.length-1];

		if (document.getElementById('equal_axes').checked) {
			ideal_yf = y0 - (xf-x0)/(d_max-d_min) * h_max;
			ideal_xf = x0 - (yf-y0)/(h_max) * (d_max-d_min);
			if 		(ideal_yf > yf) yf = ideal_yf;
			else if (ideal_xf < xf) xf = ideal_xf;
		}

		drawTicks('x', d_ticklabels, xf, x0, yf, y0, 15);
		drawTicks('y', h_ticklabels, yf, y0, xf, x0, 5);
		
		for (i in d) {
			//if(isNaN(d[i]) || isNaN(h[i])) continue;
			var pt = svg.createSVGPoint();
			pt.x = x0 + (xf-x0)/(d_max-d_min)*(d[i]-d_min);
			pt.y = y0 + (yf-y0)/(h_max-0)*h[i];
			chart_shot_area.points.appendItem(pt);
		}

		target_low  = document.getElementById('chart_target_low');
		target_high = document.getElementById('chart_target_high');
		obstacle    = document.getElementById('chart_obstacle');

		shot_area.setAttribute('fill', missed ? '#6a1a10': '#3a6a30')

		if (x_obstacle > 0) x_obstacle -= target_d;

		target_low .setAttribute("points","");
		target_high.setAttribute("points","");
		obstacle   .setAttribute("points","");

		scaling = [x0, y0, xf, yf, d_min, d_max, h_max];
		target_low.points.appendItem(makept(scaling,      0, 			0));
		target_low.points.appendItem(makept(scaling,      0, 			target_h-target_diam/2));
		target_low.points.appendItem(makept(scaling,      0+target_h/5,  target_h-target_diam/2));
		target_low.points.appendItem(makept(scaling,      0+target_h/5,  0));

		target_high.points.appendItem(makept(scaling,     0,				target_h+target_diam));
		target_high.points.appendItem(makept(scaling,     0, 			target_h+target_diam/2));
		target_high.points.appendItem(makept(scaling,     0+target_h/5,  target_h+target_diam/2));
		target_high.points.appendItem(makept(scaling,     0+target_h/5,  target_h+target_diam));

		obstacle.points.appendItem(makept(scaling, x_obstacle, 0));
		obstacle.points.appendItem(makept(scaling, x_obstacle+h_obstacle/7, 0));
		obstacle.points.appendItem(makept(scaling, x_obstacle+h_obstacle/7, h_obstacle));
		obstacle.points.appendItem(makept(scaling, x_obstacle, h_obstacle));

		/*
		var pt = svg.createSVGPoint(); pt.x = target_d; pt.y = 0; target_low.points.appendItem(pt);
		var pt = svg.createSVGPoint(); pt.x = target_d; pt.y = target_h-target_diam/2; target_low.points.appendItem(pt);
		var pt = svg.createSVGPoint(); pt.x = target_d+target_h/5; pt.y = target_h-target_diam/2; target_low.points.appendItem(pt);
		var pt = svg.createSVGPoint(); pt.x = target_d+target_h/5; pt.y = 0; target_low.points.appendItem(pt);

		var pt = svg.createSVGPoint(); pt.x = target_d; pt.y = target_h+target_diam; target_high.points.appendItem(pt);
		var pt = svg.createSVGPoint(); pt.x = target_d; pt.y = target_h+target_diam/2; target_high.points.appendItem(pt);
		var pt = svg.createSVGPoint(); pt.x = target_d+target_h/5; pt.y = target_h+target_diam/2; target_high.points.appendItem(pt);
		var pt = svg.createSVGPoint(); pt.x = target_d+target_h/5; pt.y = target_h+target_diam; target_high.points.appendItem(pt);
		*/

		/*bg=document.getElementById('chart');

		qline = document.getElementById('chart_query_line');
		qline.setAttribute('opacity', 0);

		gids('query_time', '-');
		gids('query_d', '-');
		gids('query_v', '-');
		gids('query_cur', '-');
		gids('query_f', '-');

		handler = function(event){
			if(event.buttons != 1) return;
				xq = event.clientX - bg.getBoundingClientRect().left;
				yq = event.clientY - bg.getBoundingClientRect().top;

				tq = (t_max-0)/(xf-x0)*(xq-x0);
				if (tq>Math.max(...t)){
					tq = Math.max(...t);
					xq = x0 + (xf-x0)/(t_max-0)*tq;
				}
				if (tq<0) {
					tq=0; xq=x0;
				}
				dq   = linterp(t, d, tq);
				vq   = linterp(t, v, tq);
				curq = linterp(t, cur, tq);
				fq   = linterp(t, f, tq);
				qline.setAttribute('opacity', 1);

				qline.setAttribute('x1', xq);
				qline.setAttribute('x2', xq);

				gids('query_time', tq);
				gids('query_d', dq);
				gids('query_v', vq);
				gids('query_cur', curq);
				gids('query_f', fq);
			}
		bg.addEventListener('mousemove', handler);
		bg.addEventListener('mousedown', handler);*/
	}

</script>
</script>


<script id="packed_inputs_dump">
	packed_inputs = null; // set to an object/dict (id => value) with some specials
	// unit_sys
</script>

<script>
	function pack_inputs() {
		packed_inputs = {};
		for (input of document.getElementsByTagName('input')) {
			if (input.type == "text") {
				packed_inputs[input.id] = input.value;
			}
			if (input.type == "checkbox" || input.type == "radio") {
				packed_inputs[input.id] = input.checked;
			}
		}
		for (input of document.getElementsByTagName('select')) {
			packed_inputs[input.id] = input.value;
		}

		document.getElementById("packed_inputs_dump").innerHTML = "packed_inputs="+JSON.stringify(packed_inputs)+";";
	}

	function unpack_inputs() {
		for (key in packed_inputs) {
			if (typeof packed_inputs[key] == "boolean")
				document.getElementById(key).checked = packed_inputs[key];
			else
				document.getElementById(key).value   = packed_inputs[key];
		}

		loads = document.getElementsByClassName('load');
		for (load of loads) {
			load.identifier = load.firstChild.getAttribute('identifier');
		}
		for (btn of document.getElementsByClassName('toggle_button'))
			btn.innerHTML = "&#9650;";
	}

	function readTextFile(file)
	{
		var allText = null;
	    var rawFile = new XMLHttpRequest();
	    rawFile.open("GET", file, false);
	    rawFile.onreadystatechange = function ()
	    {
	        if(rawFile.readyState === 4)
	        {
	            if(rawFile.status === 200 || rawFile.status == 0)
	            {
	                allText = rawFile.responseText;
	            }
	        }
	    }
	    rawFile.send(null);
	    return allText;
	}

	if (!String.prototype.decodeHTML) {
	  String.prototype.decodeHTML = function () {
	    return this.replace(/&apos;/g, "'")
	               .replace(/&quot;/g, '"')
	               .replace(/&gt;/g, '>')
	               .replace(/&lt;/g, '<')
	               .replace(/&amp;/g, '&')
	               .replace(/â–¼/g, '&#9650;');
	  };
	}

	months=['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
	function download_page() {
		today = new Date();
		var fileName = 'trajectory_' + today.getFullYear()+months[today.getMonth()]+today.getDate();
		fileName = prompt("Enter a filename. (.html will be appended)", fileName)
		if (!fileName) return;
		document.getElementById('topbar_fname').innerHTML = fileName;
		fileName += '.html';


		head = document.head || document.getElementsByTagName('head')[0];

		pack_inputs();

		scripts   = document.getElementsByTagName('script');
		for (script of scripts) {
			if (script.src) {
				scr = readTextFile(script.src);
				script.innerHTML = scr;
				script.removeAttribute('src');
			}
		}

		links = document.getElementsByTagName('link');
		for (link of links) {
			if (link.href) {
				scr = readTextFile(link.href);
				style = document.createElement('style');
				style.type='text/css';
				if(style.styleSheet) {
					style.styleSheet.cssText = scr;
				} else {
					style.appendChild(document.createTextNode(scr));
				}
				head.prepend(style);
				link.parentElement.removeChild(link);
			}
		}


		var fileContent = new XMLSerializer().serializeToString(document).decodeHTML();
		var myFile = new Blob([fileContent], {type: 'text/html'});
		window.URL = window.URL || window.webkitURL;
		dlurl = window.URL.createObjectURL(myFile);
		document.getElementById('download_iframe').download = fileName;
		document.getElementById('download_iframe').href = dlurl;
		document.getElementById('download_iframe').click();
	}

	function print_page() {
		window.print();
	}
</script>

<html>
<body onload="thload()">
<div id="topbar">
	<div class="topbar_la selectable" onclick="window.location='./'">EveryCalc</div>
	<div class="topbar_la" id='topbar_version'></div>
	<div class="topbar_la" id='topbar_fname'></div>
	<div class="topbar_ctr">Trajectory Calculator</div>
	<div class="topbar_ra selectable" onclick="download_page();" id="download">Export HTML</div>
	<div class="topbar_ra selectable" onclick="print_page();">Print</div>
	<a id="download_iframe" hidden></a>
</div>
	<div style="width: 100%; float: left;" class="container">
		<div class="even" style=''>
			<table>
				<tr>
					<td>
					  <input type="radio" id="unit_english" name="unit" value="english" onclick="switch_units()" checked> English
					</td><td>
					  <input type="radio" id="unit_inches" name="unit" value="inches" onclick="switch_units()">
					  Inches
					</td><td>
					  <input type="radio" id="unit_metric" name="unit" value="metric" onclick="switch_units()"> Metric
					</td><td class="rowlabel">
						Mode: <span class="ttt">How the solver should be ran.<br/>Blind: allows full control of all fields.<br/> Find theta/velocity will find the angle or velocity needed given the other parameter.<br/>Find Minimum will find the minimum velocity needed and the corresponding angle.</span>
					</td><td>
						<select id="mode" onchange="mode_select(); compute();">
							<option value="raw" selected='selected'>Blind Adjustment</option>
							<option value="find_theta">Find Angle</option>
							<option value="find_v">Find Velocity</option>
							<option value="find_min_v">Find Minimum Velocity</option>
							<option value="find_distance_near">Find Near Distance</option>
							<option value="find_distance_far" >Find Far Distance</option>
						</select>
					</td>
				</tr>
			</table>
		</div>

		<div style='display:table-row'>
		<div class="odd" style='display:table-cell'>
			<table>
				<tr>
					<th class='rowlabel'>Launch Angle</th>
					<td><input id='theta' value=30><td class="tiny">+/-</td>
					<td><input id='theta_err' value=''></td>
					<td class='unit' id='unit_theta'></td>
				</tr><tr>
					<th class="rowlabel">Launch Velocity</th>
					<td><input id="v_initial" value=45></td><td class="tiny">+/-</td>
					<td><input id="v_initial_err" value=''></td>
					<td class="unit" id='unit_v_initial'></td>
				</tr><tr>
					<th class="rowlabel">Backspin</th>
					<td><input id="omega_initial" value=''></td><td class="tiny">+/-</td>
					<td><input id="omega_initial_err" value=''></td>
					<td class="unit" id='unit_omega_initial'></td>
				</tr><tr>
					<th class='rowlabel'>Distance to Target</th>
					<td><input id='x_target' value=15></td><td class="tiny">+/-</td>
					<td><input id="x_target_err" value=''></td>
					<td class="unit" id='unit_x_target'></td>
				</tr><tr>
					<th class="rowlabel">Launch Height</th>
					<td><input id="y_initial" value=1.5></td><td class="tiny">+/-</td>
					<td><input id="y_initial_err" value=''></td>
					<td class="unit" id='unit_y_initial'></td>
				</tr><tr>
					<th class='rowlabel'>Projectile Diameter</th>
					<td><input id='d_ball' value=7></td><td class="tiny">+/-</td>
					<td><input id='d_ball_err' value=''></td>
					<td class='unit' id='unit_d_ball'></td>
				</tr><tr>
					<th class='rowlabel'>Projectile Mass</th>
					<td><input id='m_ball' value=0.5></td><td class="tiny">+/-</td>
					<td><input id='m_ball_err' value=''></td>
					<td class='unit' id='unit_m_ball'></td>
				</tr><tr>
					<th class="rowlabel">Drag Coefficient</th>
					<td><input id="Cd" value=''></td><td class="tiny">+/-</td>
					<td><input id="Cd_err" value=''></td>
					<td class="unit" id='unit_Cd'></td>
				</tr><tr>
					<th class='rowlabel'>Lift Coefficient</th>
					<td><input id='Cl' value=''></td><td class="tiny">+/-</td>
					<td><input id='Cl_err' value=''></td>
					<td class='unit' id='unit_Cl'></td>
				</tr><tr>
					<th class='rowlabel'>Magnus Coefficient</th>
					<td><input id='Cm' value=''></td><td class="tiny">+/-</td>
					<td><input id='Cm_err' value=''></td>
					<td class='unit' id='unit_Cm'></td>
				</tr><tr>
					<th class="rowlabel">Target Center Height</th>
					<td><input id="y_target" value=8></td>
					<td class="unit" id='unit_y_target'></td>
				</tr><tr>
					<th class="rowlabel">Target Height</th>
					<td><input id="h_target" value=30></td>
					<td class="unit" id='unit_h_target'></td>
				</tr><tr>
					<th class="rowlabel">Obstacle Position<span class="ttt">Position of the obstacle. Positive numbers will be relative to launch position. Negative will be relative to target.</span></th>
					<td><input id="x_obstacle" value=></td>
					<td class="unit" id='unit_x_obstacle'></td>
				</tr><tr>
					<th class="rowlabel">Obstacle Height</th>
					<td><input id="h_obstacle" value=></td>
					<td class="unit" id='unit_h_obstacle'></td>
				</tr>
			</table>
		</div><div class="output" style='display:table-cell'>
			<button type="button" onclick="compute()" id="compute_btn">Compute!</button>
			<input type="checkbox" id="equal_axes" Name="equal_axes" onchange="compute(true)" checked> <label for="equal_axes">Equal Plot Axes</label>
			<table>
				<tr>
					<th class='rowlabel'>Strike Point</th>
					<td><input id='strike_height' readOnly></td><td class="tiny">+/-</td>
					<td><input id='strike_height_err' readOnly></td>
					<td class='unit' id='unit_strike_height'></td>
				</tr><tr>
					<th class='rowlabel'>Swept Zone</th>
					<td><input id='sweep_height' readOnly></td><td class="tiny">+/-</td>
					<td><input id='sweep_height_err' readOnly></td>
					<td class='unit' id='unit_sweep_height'></td>
				</tr><tr>
					<th class="rowlabel">Angle of Strike</th>
					<td><input id="strike_angle" readOnly></td><td class="tiny">+/-</td>
					<td><input id="strike_angle_err" readOnly></td>
					<td class="unit" id='unit_strike_angle'></td>
				</tr><tr>
					<th class="rowlabel">Time of Flight</th>
					<td><input id="time_of_flight" readOnly></td><td class="tiny">+/-</td>
					<td><input id="time_of_flight_err" readOnly></td>
					<td class="unit" id='unit_time_of_flight'>[s]</td>
				</tr>
			</table>
		</div>
		<div class="even" style='display:table-cell'>
			<table id="table_protips">
				<tr>
					<th class='rowlabel' colspan=2 class="toggle_button">Pro-Tips</th>
					<td>
						<button type="button" onclick="collapse('protips'); shape_select(true)" id='toggle_detail_protips'>&#9650;</button>
					</td>
				</tr>
				<tr>
					<td colspan=3>
							When the chart background is yellow, computation is needed; hit enter or press compute.</br/><br/>
							When the chart background is red, the current combination of inputs cannot be solved for.
					</td>
				</tr>
			</table>
		</div>
	</div>
	
<div style="margin-left: 0px; display:table-cell;" class="container" id="charts">
<svg version="1.2" class="graph" id='chart' aria-labelledby="title" role="img">
  <title id="title">Position Chart</title>


	<rect class="background" id="chart_background" x=70 y=20 width=710 height=430 />
	<g class="x-grid">
	  <line id="chart_x_axis" class="axes" x1="70" x2="780" y1="450" y2="450"></line>
	</g>
	<g class="y-grid">
	  <line id="chart_y_axis" class="axes" x1="70" x2="70" y1="20" y2=450></line>
	</g>

	<g class="x-grid" id="chart_x_grid"></g>
	<g class="y-grid" id="chart_y_grid"></g>

	<g class="labels x-labels" id='chart_x_labels'>
	  <text x=375 y=485 class="label-title" id="chart_x_label">Distance [ft]</text>
	</g>

	<g class="labels y-labels" id='chart_y_labels'>
	  <text x=-360 y=20 class="label-title" transform="rotate(270)" id="chart_y_label">Height [ft]</text>
	</g>

	<g class="labels x-labels" id='chart_x_axis_labels'></g>
	<g class="labels y-labels" id='chart_y_axis_labels'></g>

	<g class="query-line">
		<!--<line id="chart_query_line" x1=100 x2=100 y1=15 y2=455></line>-->
	</g>
	<polyline
		id='chart_shot_area'
		fill='#3a6a30'
		stroke='#3a6a30'
		stroke-width=2
		fill-opacity=0.5
		points="
		"/>
	<polyline
		id='chart_target_low'
		fill="#444"
		stroke='none'
		opacity=1.0
		points=""/>
	<polyline
		id='chart_target_high'
		fill="#444"
		stroke='none'
		opacity=1.0
		points=""/>
	<polyline
		id='chart_obstacle'
		fill="#444"
		stroke='none'
		opacity=1.0
		points=""/>
</svg>			

		</div>
	</div>
</body>
</html>